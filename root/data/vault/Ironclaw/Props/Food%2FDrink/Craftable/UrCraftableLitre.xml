<object clone="/base/obj/thing" owner="jominey">
  <Base:Thing>
    <Ur:UrObject urobject="OBJ(Shared:food/drinks:sizes:measured:metric:Litre)"/>
    <Base:Bulk immobile="false" mass="1" density="1"/>
    <Base:Container flexible="false" transparent-container="false" public-container="false" tight="false" capacity="1" maxweight="1"/>
    <Base:Misc gender="neuter" volition="false" weapon="false" default_stance="none" combinable="false" discrete="false" by_weight="false" tight="false" scriptrunner="false">
      <Base:Edible value="false"/>
      <Base:Potable value="false"/>
      <Base:DrinkMessageFirst></Base:DrinkMessageFirst>
      <Base:DrinkMessageThird></Base:DrinkMessageThird>
      <Base:Transparency value="false"/>
      <Base:Unsafe value="false"/>
      <Base:Safe value="false"/>
      <Base:ClothesExpected value="false"/>
      <Base:DieMessageFirst></Base:DieMessageFirst>
      <Base:DieMessageThird></Base:DieMessageThird>
    </Base:Misc>
    <Base:Details>
      <Base:Detail id="default" prime="true" def="false" abstract="false" hidden="false" luminosity="0" targetable_in_dark="false" plural="false">
        <Base:Preposition close="false" against="false" under="false" on="false" inside="false" near="false" over="false" behind="false" before="false" beside="false"/>
        <Base:Names>
          <Base:SNames>
            <Base:SName sname="thing"/>
          </Base:SNames>
          <Base:PNames>
            <Base:PName pname="things"/>
          </Base:PNames>
        </Base:Names>
        <Base:Adjectives/>
        <Base:Descriptions>
          <Base:Description type="examine">
             <a_or_an>$(this.trait:size) {? equal | $(this.trait:color) | none | {? equal | $(this.trait:material) | none | plain | $(this.trait:material) } | $(this.trait:color) {? equal | $(this.trait:material) | none || $(this.trait:material) } } $(this.trait:type) $(this.trait:brief). $[ParseXML(Str(NRefOb($target)."trait:examine"))] {? | $(this.trait:lacquer) | It is lacquered with a $(this.trait:lacquer) finish.} {? | $(this.trait:variation) | It bears a $(this.trait:variation) design.} {? | $(this.details:gem:snames) | Remarkable $(this.trait:gem:color) $(this.trait:gem:material)s are embedded into the piece.} {? | $(this.trait:engraving) | $(this.trait:engraving)} {? | $(this.trait:painting) | $(this.trait:painting)} <makers-mark/> <sbr/><quality-full/></a_or_an>
          </Base:Description>
          <Base:Description type="look">
             <a_or_an>$(this.trait:size) {? equal | $(this.trait:color) | none | {? equal | $(this.trait:material) | none | plain | $(this.trait:material) } | $(this.trait:color) {? equal | $(this.trait:material) | none || $(this.trait:material) } } $(this.trait:type) $(this.trait:brief). {? | $(this.trait:lacquer) | It is lacquered with a $(this.trait:lacquer) finish.} {? | $(this.trait:variation) | It bears a $(this.trait:variation) design.} {? | $(this.details:gem:snames) | Remarkable $(this.trait:gem:color) $(this.trait:gem:material)s are embedded into the piece.} {? | $(this.trait:engraving) | $(this.trait:engraving)} {? | $(this.trait:painting) | $(this.trait:painting)} </a_or_an>
          </Base:Description>
          <Base:Description type="type">
             $(this.trait:size) {? | $(this.trait:gem:inlay) | $(this.trait:gem:material)-$(this.trait:gem:inlay) } {? equal | $(this.trait:pearl) | none || $(this.trait:pearl) } {? equal | $(this.trait:color) | none || $(this.trait:color) } {? | $(this.trait:engraving) | {? | $(this.trait:engraving:pattern) | $(this.trait:engraving:pattern)} engraved } {? | $(this.trait:painting) | {? | $(this.trait:painting:pattern) | $(this.trait:painting:pattern)} painted } {? equal | $(this.trait:material) | none || $(this.trait:material) } $(this.trait:type) $(this.trait:brief)
          </Base:Description>
        </Base:Descriptions>
        <Base:Exit door="false" never_obvious="false" obvious_when_open="false" hidden_when_closed="false" separate="false" self-locking="false" deadbolt="false"/>
        <Base:Climbable/>
      </Base:Detail>
      <Base:Detail id="gempieces" prime="false" def="false" abstract="false" hidden="false" luminosity="0" targetable_in_dark="false" plural="false">
        <Base:Preposition close="false" against="false" under="false" on="false" inside="false" near="false" over="false" behind="false" before="false" beside="false"/>
        <Base:Names>
          <Base:SNames/>
          <Base:PNames/>
        </Base:Names>
        <Base:Adjectives/>
        <Base:Descriptions>
          <Base:Description type="brief">
             the {? equal | $(this.trait:gem:color) | none | gaudy | $(this.trait:gem:color) }{? equal | $(this.trait:gem:material) | none | gaudy | $(this.trait:gem:material)s } adoring the $(this.details:default:descriptions:brief)
          </Base:Description>
          <Base:Description type="look">
             A fine assortment of {? equal | $(this.trait:gem:color) | none | gaudy | $(this.trait:gem:color) } {? equal | $(this.trait:gem:material) | none | gaudy | $(this.trait:gem:material)s } adorning this $(this.details:default:descriptions:brief).
          </Base:Description>
        </Base:Descriptions>
        <Base:Exit door="false" never_obvious="false" obvious_when_open="false" hidden_when_closed="false" separate="false" self-locking="false" deadbolt="false"/>
        <Base:Climbable/>
      </Base:Detail>
    </Base:Details>
    <Base:Combat>
      <Base:Strength value="1"/>
      <Base:MaxFatigue value="1"/>
    </Base:Combat>
    <Base:Clothing>
      <Base:SingleWear value="false"/>
    </Base:Clothing>
    <Base:Crafting see_level="0" do_level="0" time="0" attention="false" held="false">
      <Base:Ingredients/>
      <Base:Tools/>
      <Base:CraftVerbs/>
    </Base:Crafting>
    <Base:InitialContents/>
    <Base:InitialProperties/>
    <Core:Properties>
      <Core:Property property="backup:merry:react:add-iob">
         X[M] /*EmitTo(\$actor, "Args = " + dump_value(args));*/    
/* Check if we were given a direct object to add to the indirect object */    
if(!\$dob) \{    
return TRUE;    
\}    
    
/* check we were only given one direct object */    
if(sizeof(\$dob) \> 1) \{    
  EmitTo(\$actor, "You can only add one object at a time");    
  return FALSE;    
\} else \{    
  \$dob = NRefOb(\$dob[0]);    
\}    
    
/* this check should also be in the object being added */    
if(sizeof(\$iob) \> 1) \{    
  EmitTo(\$actor, "You can only add to one object at a time");    
  return FALSE;    
\} else \{    
\}    
    
/* Check if we are allowed to add the iob to the dob */    
/*EmitTo(\$actor, "Adding " + Describe(\$dob) + " to " + Describe(\$iob));*/    
if(!(\$addlist = Get(NRefOb(\$iob[0]), "alteration:add:" + NRefDetail(\$iob[0]) + ":" + Str(\$dob."trait:objecttype"))))    
\{    
  EmitTo(\$actor, "You can't combine these objects");    
  return FALSE;    
\}    
    
/* We can combine the objects */    
    
    
/* Check if these two combined creates a new object */    
/* (assume it doesn't, until I write this code) */    
/* set whichever is the updated object to be \$object */    
\$object = NRefOb(\$iob[0]);    
    
/* If this is going to the existing object */    
/* Check if we already have this object type added    
(i.e. adding lace to a shirt that already has lace) */    
/* what if this detail doesn't exist in the target? */    
if(sizeof(Get(\$object, "details:" + \$dob."trait:objecttype" + ":snames")) \> 0)    
\{    
  /* The object already has snames for this detail, so we assume it has already been added previously */    
  EmitTo(\$actor, "You cannot combine these, " + Describe(\$object, nil, \$actor) + " already has " + Describe(NewNRef(\$object, \$dob."trait:objecttype"), \$actor, nil, STYLE_NONPOSS) + ".");    
  return FALSE;    
\}    
    
/* Check which new details need to be added to the new object */    
  /* add detail snames/pnames and adjectives */    
if(\$addlist["names"])    
\{    
  for(\$i = 0; \$i \< sizeof(\$addlist["names"]); \$i++)    
  \{    
    if(sizeof(\$addlist["names"][\$i]) == 2)    
    \{    
      Set(\$object, "details:" + \$dob."trait:objecttype" + ":" + \$addlist["names"][\$i][0] + ":" + \$addlist["names"][\$i][1], 1);    
    \}    
  \}    
\}    
    
/* Check which old adjectives need to be removed from the object */    
/* Adjectives to be removed from the detail. E.g. removing the current colour of an object when adding a new colour */    
/* Based on the objects current properties, NOT the dob's properties */    
if(\$addlist["adj-remove"])    
\{    
  /* Code goes here. */    
\}    
    
/* Check which new adjectives need to be added to the object */    
/* Adjectives for the detail, copied from a property */    
if(\$addlist["adj-prop"])    
\{    
  for(\$i=0;\$i\<sizeof(\$addlist["adj-prop"]);\$i++)    
  \{    
    if(Get(\$dob, \$addlist["adj-prop"][\$i]))    
    \{    
      Set(\$object, "details::" + \$dob."trait:objecttype" + ":adjective:" + Get(\$dob, \$addlist["adj-prop"][\$i]), 1);    
    \}    
  \}    
\}    
    
/* Adjectives for the default, copied from a property */    
if(\$addlist["adj-prop-default"])    
\{    
  for(\$i=0;\$i\<sizeof(\$addlist["adj-prop-default"]);\$i++)    
  \{    
    Set(\$object, "details:default:adjective:" + Get(\$dob, \$addlist["adj-prop-default"][\$i]), 1);    
  \}    
\}    
    
/* Adjectives for the default, copied from a list */    
if(\$addlist["adj-list-default"])    
\{    
  for(\$i=0;\$i\<sizeof(\$addlist["adj-list-default"]);\$i++)    
  \{    
    Set(\$object, "details:default:adjective:" + \$addlist["adj-list-default"][\$i], 1);    
  \}    
\}    
    
/* Check which properties should be copied to the new object */    
if(\$addlist["properties"])    
\{    
  for(\$i=0;\$i\<sizeof(\$addlist["properties"]);\$i++)    
  \{    
    if((sizeof(\$addlist["properties"][\$i]) == 2) \&\& Get(\$dob, \$addlist["properties"][\$i][0]))    
    \{    
      Set(\$object, \$addlist["properties"][\$i][1], Get(\$dob, \$addlist["properties"][\$i][0]));    
    \}    
  \}    
\}    
    
/* Slay the original object(s) */    
if(!\$addlist["noslay"])    
\{    
  Slay(\$dob);    
\}    
    
return TRUE;
      </Core:Property>
      <Core:Property property="backup:merry:react:change-dob">
         X[M] /*Check if we have a target to alter the object to*/    
EmitTo(\$actor, "checking for raw input");    
    
if(!\$(into:words)) \{    
  EmitTo(\$actor, "No input");    
  return TRUE;    
\}    
    
/* We have a target to alter the object to */    
EmitTo(\$actor, "We have raw input of size " + sizeof(\$(into:words)));    
\$targetwords = implode(\$(into:words), " ");    
EmitTo(\$actor, "target is " + \$targetwords);    
    
/* Check we only have one dob */    
    
/* check we were only given one direct object */    
if(sizeof(\$dob) \> 1) \{    
  EmitTo(\$actor, "You can only alter one object at a time");    
  return FALSE;    
\}    
    
/* verify this is a valid target */    
    
/* Check if the actor is using any necessary tools */    
    
  /* if not, check if the actor has the tools in their posession */    
    
return FALSE;
      </Core:Property>
      <Core:Property property="export:alteration:add:default:gempieces">
         ([ "adj-prop":(\{ "trait:color", "trait:material" \}), "names":(\{ (\{ "sname", "gem" \}), (\{ "pname", "gems" \}) \}), "properties":(\{ (\{ "trait:color", "trait:gem:color" \}), (\{ "trait:material", "trait:gem:material" \}), (\{ "trait:gem:inlay", "trait:gem:inlay" \}) \}) ])
      </Core:Property>
      <Core:Property property="export:nip:item:cost">
         700
      </Core:Property>
      <Core:Property property="export:quality_description">
         X[S] This \$(this.details:default:descriptions:brief) appears to be of
\{?when\| \$(this.trait:quality) \| 1 \|               terrible               \| 2 \|               bad               \| 3 \|               poor               \| 4 \|               average               \| 5 \|               average               \| 6 \|               good               \| 7 \|               very good               \| 8 \|               superb               \| 9 \|               outstanding               \| 10 \|               exceptional               \| 11 \|               magnificent               \| 12 \|               unsurpassed               \| * \|               average \}
quality.
      </Core:Property>
      <Core:Property property="export:trait:brief">
         "furnishing"
      </Core:Property>
      <Core:Property property="export:trait:objecttype">
         "furnishing"
      </Core:Property>
      <Core:Property property="export:trait:quality">
         4
      </Core:Property>
      <Core:Property property="export:writable">1</Core:Property>
      <Core:Property property="merry:inherit:react-pre:engrave-dob">
         \<Allegory:Lib:Crafting:Custom:Engraving\>
      </Core:Property>
      <Core:Property property="merry:lib:add">
         X[M] int counter;    
/*EmitTo(\$actor, "Args = " + dump_value(args));*/    
    
/* We should have already checked that we have two valid objects that can be added */    
/* Make sure that the react-pre:add-iob is there, it does the checking */    
    
/* Check again anyway */    
if(!\$addition) return TRUE;    
if(!Call(\$\{Ironclaw:Lib:Crafting:Lib\}, "valid-check", \$addition: \$addition, \$object: \$target))    
\{ return FALSE; \}    
    
\$addition = NRefOb(\$addition[0]);    
    
/* Check if we are allowed to add the addition to the object */    
/*EmitTo(\$actor, "Adding " + Describe(\$addition) + " to " + Describe(\$target));*/    
if(!(\$addlist = Get(NRefOb(\$target[0]), "alteration:add:" + NRefDetail(\$target[0]) + ":" + Str(\$addition."trait:objecttype"))))    
\{    
  EmitTo(\$actor, "You can't combine these objects");    
  return FALSE;    
\}    
    
/* We can combine the objects */    
    
/* Check that this modification hasn't already been made */    
if(\$addlist["stopvalue"]) \{    
  /* We have a stopvalue. Check if we are allowed to continue */    
  /* If this property exists in the object, then we need to stop, unless it matches the value */    
  if(Get(NRefOb(\$target[0]), \$addlist["stopvalue"][0])) \{    
    /* if stopvalue doesn't match the property, then exit with message*/    
    if((sizeof(\$addlist["stopvalue"]) \> 1) \&\& (Get(NRefOb(\$target[0]), \$addlist["stopvalue"][0]) != \$addlist["stopvalue"][1])) \{    
      /* Stopvalue doesn't match. Output error message */    
      if(sizeof(\$addlist["stopvalue"]) \> 2) \{    
        EmitTo(\$actor, \$addlist["stopvalue"][2]);    
      \} else \{    
        EmitTo(\$actor, Describe(\$target[0], nil, \$actor) + " already has a modification of that type.");    
      \}    
      return FALSE;    
    \}    
  \}    
\}    
    
    
/* Check if the actor is carrying any necessary tools */    
if(\$tmp = \$addlist["requiredtools"])    
\{    
  /*We require tools*/    
  for(counter=1; counter\<sizeof(\$tmp); counter++)    
  \{    
    /*We need a tool*/    
    \$found = nil;    
    for(\$i = 0; (\$i \< sizeof(\$tmp[counter]))\&\&(!\$found); \$i++)    
    \{    
      /*We need a tool of type \$tmp[counter][\$i] */    
      for(\$j = 0; (\$j \< sizeof(\$actor."base:inventory"))\&\&(!\$found); \$j++)    
      \{    
        if(\$actor."base:inventory"[\$j]."trait:objecttype" == \$tmp[counter][\$i])    
        \{    
          /*We found the tool!*/    
          \$found = 1;    
        \}    
      \}    
    
      /* We didn't find the tool in our inventory. Is the player "using" the tool? */    
      if(!\$found \&\& \$using)    
      \{    
        for(\$j=0; (\$j \< sizeof(\$using))\&\&(!\$found); \$j++)    
        \{    
          if(NRefOb(\$using[\$j])."trait:objecttype" == \$tmp[counter][\$i])    
          \{    
            /*We found the tool!*/    
            /* make sure someone else isn't holding it */    
            if(NRefOb(\$using[\$j])."base:environment"."base:volition")    
            \{    
              EmitTo(\$actor, "You can't use a tool that's being held by someone else.");    
              return FALSE;    
            \} else \{    
              \$found = 1;    
            \}    
          \}    
        \}    
      \}    
    \}    
    /* If we are missing a tool we need */    
    if(!\$found)    
    \{    
      EmitTo(\$actor, "You can't combine "+Describe(\$target[0], nil, \$actor)+" and "+Describe(\$addition, nil, \$actor)+" without "+\$tmp[0]+".");    
      return FALSE;    
    \}    
  \}    
\}    
    
    
/* Check if these two combined creates a new object */    
/* set whichever is the updated object to be \$object */    
if(\$addlist["newobject"])    
\{    
  \$target = NRefOb(\$target[0]);    
  \$object = Spawn(\$addlist["newobject"]);    
  \$object."base:environment" = \$target."base:environment";    
\} else \{    
  \$object = NRefOb(\$target[0]);    
  \$target = NRefOb(\$target[0]);    
    
  /* If this is going to the existing object */    
  /* Check if we already have this object type added    
  (i.e. adding lace to a shirt that already has lace) */    
  /* what if this detail doesn't exist in the target? */    
  if(sizeof(Get(\$object, "details:" + \$addition."trait:objecttype" + ":snames")) \> 0)    
  \{    
    /* The object already has snames for this detail, so we assume it has already been added previously */    
    EmitTo(\$actor, "You cannot combine these, " + Describe(\$object, nil, \$actor) + " already has " + Describe(NewNRef(\$object, \$addition."trait:objecttype"), \$actor, nil, STYLE_NONPOSS) + ".");    
    return FALSE;    
  \}    
    
\}    
    
/* Check which new details need to be added to the new object */    
  /* add detail snames/pnames and adjectives */    
if(\$addlist["names"])    
\{    
  for(\$i = 0; \$i \< sizeof(\$addlist["names"]); \$i++)    
  \{    
    if(sizeof(\$addlist["names"][\$i]) == 2)    
    \{    
      Set(\$object, "details:" + \$addition."trait:objecttype" + ":" + \$addlist["names"][\$i][0] + ":" + \$addlist["names"][\$i][1], 1);    
    \} else if(sizeof(\$addlist["names"][\$i]) \> 2)    
    \{    
      for(\$j = 1; \$j \< sizeof(\$addlist["names"][\$i]); \$j++)    
      \{    
        Set(\$object, "details:" + \$addition."trait:objecttype" + ":" + \$addlist["names"][\$i][0] + ":" + \$addlist["names"][\$i][\$j], 1);    
      \}    
    \}    
  \}    
\}    
    
/* Adjectives to be removed from the detail. E.g. removing the current colour of an object when adding a new colour */    
/* This should be in the object as a setprop-post trigger */    
    
/* Check which new adjectives need to be added to the object */    
/* This should probably also be set as a setprop post. But it's useful, so I've got both options */    
/* Adjectives for the detail, copied from a property */    
if(\$addlist["adj-prop"])    
\{    
  for(\$i=0;\$i\<sizeof(\$addlist["adj-prop"]);\$i++)    
  \{    
    if(Get(\$addition, \$addlist["adj-prop"][\$i]))    
    \{    
      Set(\$object, "details:" + \$addition."trait:objecttype" + ":adjective:" + Get(\$addition, \$addlist["adj-prop"][\$i]), 1);    
    \}    
  \}    
\}    
    
/* Adjectives for the default, copied from a property */    
if(\$addlist["adj-prop-default"])    
\{    
  for(\$i=0;\$i\<sizeof(\$addlist["adj-prop-default"]);\$i++)    
  \{    
    Set(\$object, "details:default:adjective:" + Get(\$addition, \$addlist["adj-prop-default"][\$i]), 1);    
  \}    
\}    
    
/* Adjectives for the default, copied from a list */    
if(\$addlist["adj-list-default"])    
\{    
  for(\$i=0;\$i\<sizeof(\$addlist["adj-list-default"]);\$i++)    
  \{    
    Set(\$object, "details:default:adjective:" + \$addlist["adj-list-default"][\$i], 1);    
  \}    
\}    
    
/* Check which properties should be copied to the new object */    
if(\$addlist["properties"])    
\{    
  for(\$i=0;\$i\<sizeof(\$addlist["properties"]);\$i++)    
  \{    
    if((sizeof(\$addlist["properties"][\$i]) == 2) \&\& Get(\$addition, \$addlist["properties"][\$i][0]))    
    \{    
      Set(\$object, \$addlist["properties"][\$i][1], Get(\$addition, \$addlist["properties"][\$i][0]));    
    \}    
  \}    
\}    
    
/* Check which properties should be copied to the new object */    
if(\$addlist["properties-this"])    
\{    
  for(\$i=0;\$i\<sizeof(\$addlist["properties-this"]);\$i++)    
  \{    
    if((sizeof(\$addlist["properties-this"][\$i]) == 2) \&\& Get(\$addition, \$addlist["properties-this"][\$i][0]))    
    \{    
      Set(\$object, \$addlist["properties-this"][\$i][1], Get(\$addition, \$addlist["properties-this"][\$i][0]));    
    \}    
  \}    
\}    
    
/* Check which properties should be copied to the new object */    
if(\$addlist["properties-list"])    
\{    
  for(\$i=0;\$i\<sizeof(\$addlist["properties-list"]);\$i++)    
  \{    
    if(sizeof(\$addlist["properties-list"][\$i]) == 2)    
    \{    
      Set(\$object, \$addlist["properties-list"][\$i][0], \$addlist["properties-list"][\$i][1]);    
    \}    
  \}    
\}    
    
/* Check if we should make a skill roll, to see if the quality changes */    
if(\$addlist["skill"])    
\{    
  \$result = Call(\$\{IronClaw:Lib:UrPeople:System\}, "roll", \$dicearray: (\{ \$actor."trait:mind", Get(\$actor, "skill:alteration:"+\$addlist["skill"]), Get(\$actor, "career:alteration:"+\$addlist["skill"]) \}) );    
  if(!\$addition."trait:quality") \$addition."trait:quality" = 4;    
  if(!\$target."trait:quality") \$target."trait:quality" = 4;    
  if(\$addition."trait:quality" \> \$target."trait:quality")    
  \{    
    \$max = \$addition."trait:quality";    
    \$min = \$target."trait:quality";    
  \} else \{    
    \$max = \$target."trait:quality";    
    \$min = \$addition."trait:quality";    
  \}    
  if(\$result \> \$max) \{    
    \$object."trait:quality" = \$max+1;    
  \} else if(\$result \< \$min) \{    
    \$object."trait:quality" = \$min-1;    
  \} else \{    
    \$object."trait:quality" = \$result;    
  \}    
\}    
    
/* Slay the original object(s) */    
if(!\$addlist["noslay"])    
\{    
  Slay(\$addition);    
  if(\$addlist["newobject"])    
  \{    
    Slay(\$target);    
  \}    
\}    
    
return TRUE;
      </Core:Property>
      <Core:Property property="merry:lib:create">
         X[M] /*Check if we have a target to alter the object to*/    
string * blocklist;    
int counter;    
string input_words;    
mapping changemap;    
mapping changemap2;    
object new_object;    
string * valid_options;    
string tmp_string;    
    
blocklist = (\{ "input-list", "input-list-actor", "requiredtools", "description", "newobject", "newobject-properties", "noslay", "properties", "stopvalue", "skill", "fixed", "noskillroll", "cost" \});    
    
/* check we were only given one direct object */    
if(!\$target \|\| sizeof(\$target) \> 1) \{    
  EmitTo(\$actor, "You can only alter one object at a time");    
  return FALSE;    
\}    
    
if(!\$words) \{    
  if(\$words_string) \{    
    input_words = \$words_string;    
    sscanf(input_words, "\\"%s\\"", input_words);    
  \} else \{    
    input_words = "default";    
  \}    
\} else \{    
  /* We have a target to alter the object to */    
  input_words = implode(\$words, " ");    
\}    
    
/* Remove any "a" "the" "an" etc. from the targetwords */    
sscanf(input_words, "a %s", input_words);    
sscanf(input_words, "an %s", input_words);    
sscanf(input_words, "the %s", input_words);    
    
/* Replace any apostrophes. Players are too erratic in their use */    
input_words = replace_strings(input_words, "'", "");    
    
/* Check that input_words isn't included in the blocklist */    
for(counter = 0; counter \< sizeof(blocklist); counter++)    
\{    
  if(input_words == blocklist[counter])    
  \{    
    EmitTo(\$actor, "Invalid input.");    
    return FALSE;    
  \}    
\}    
    
/* Check what modification is being made */    
/* E.g. A symbol being sewn onto a shirt, or iron being forged into something new */    
if(!\$modification) \{    
  EmitTo(\$actor, "Unknown modification.");    
  return FALSE;    
\}    
    
/* verify this is a valid modification */    
if(!(changemap = Get(NRefOb(\$target[0]), "alteration:create:" + NRefDetail(\$target[0]) + ":" + \$modification))) \{    
  EmitTo(\$actor, "You can't " + \$modification + " " + Describe(\$target[0], nil, \$actor) + ".");    
  return FALSE;    
\}    
    
/* Check that we are holding the object we are modifying */    
  /* Unless we are allowed to modify without holding */    
if(!changemap["fixed"])    
\{    
  if(NRefOb(\$target[0])."base:environment" != \$actor)    
  \{    
    EmitTo(\$actor, "You can't " + \$modification + " " + Describe(\$target[0], nil, \$actor) + " if you are not holding it.");    
    return FALSE;    
  \}    
\}    
    
/* Check if the actor is carrying any necessary tools */    
if(\$tmp = changemap["requiredtools"])    
\{    
  /*We require tools*/    
  for(counter=1; counter\<sizeof(\$tmp); counter++)    
  \{    
    /*We need a tool*/    
    \$found = nil;    
    for(\$i = 0; (\$i \< sizeof(\$tmp[counter]))\&\&(!\$found); \$i++)    
    \{    
      /*We need a tool of type \$tmp[counter][\$i] */    
      for(\$j = 0; (\$j \< sizeof(\$actor."base:inventory"))\&\&(!\$found); \$j++)    
      \{    
        if(\$actor."base:inventory"[\$j]."trait:objecttype" == \$tmp[counter][\$i])    
        \{    
          /*We found the tool!*/    
          \$found = 1;    
        \}    
      \}    
      /* We didn't find the tool in our inventory. Is the player "using" the tool? */    
      if(!\$found \&\& \$using)    
      \{    
        for(\$j=0; (\$j \< sizeof(\$using))\&\&(!\$found); \$j++)    
        \{    
          if(NRefOb(\$using[\$j])."trait:objecttype" == \$tmp[counter][\$i])    
          \{    
            /*We found the tool!*/    
            /* make sure someone else isn't holding it */    
            if(NRefOb(\$using[\$j])."base:environment"."base:volition")    
            \{    
              EmitTo(\$actor, "You can't use a tool that's being held by someone else.");    
              return FALSE;    
            \} else \{    
              \$found = 1;    
            \}    
          \}    
        \}    
      \}    
    \}    
    /* If we are missing a tool we need */    
    if(!\$found)    
    \{    
      EmitTo(\$actor, "You can't "+\$modification+" "+Describe(\$target[0], nil, \$actor)+" without "+\$tmp[0]+".");    
      return FALSE;    
    \}    
  \}    
\}    
    
/* Check that the character isn't wearing the object */    
if(NRefOb(\$target[0])."base:clothing:worn")    
\{    
  EmitTo(\$actor, "You can't "+\$modification+" "+Describe(\$target[0], nil, \$actor)+" while you are wearing it.");    
  return FALSE;    
\}    
    
/* Check if we were passed the input, and if so, if it's valid */    
/* Get details for the modification */    
if(!(changemap2 = changemap[input_words]))    
\{    
  /* if property set, check in the actor for valid input */    
  if(changemap["input-list-actor"])    
  \{    
    for(counter = 0; counter \< sizeof(changemap["input-list-actor"]); counter++)    
    \{    
      if(Get(\$actor, changemap["input-list-actor"][counter]) \&\& (changemap2 = Get(\$actor, changemap["input-list-actor"][counter])[input_words])) break;    
    \}    
  \}    
  /* if not found, and property set, search other places for valid input */    
  if(!changemap2 \&\& changemap["input-list"])    
  \{    
    for(counter = 0; counter \< sizeof(changemap["input-list"]); counter++)    
    \{    
      /* Check if the object exists, and if we can retrieve the property */    
      if(changemap["input-list"][counter][0] \&\& Get(changemap["input-list"][counter][0], changemap["input-list"][counter][1]) \&\& (changemap2 = Get(changemap["input-list"][counter][0], changemap["input-list"][counter][1])[input_words])) break;    
    \}    
  \}    
    
  /* If we don't have valid input to modify the object */    
  /* Output valid options, then exit */    
  if(!changemap2)    
  \{    
    /* Check if we are allowed to continue, or if there is a stopvalue */    
    if(changemap["stopvalue"]) \{    
      /* We have a stopvalue. Check if we are allowed to continue */    
      /* If this property exists in the object, then we need to stop, unless it matches the value */    
      if(Get(NRefOb(\$target[0]), changemap["stopvalue"][0])) \{    
        /* if stopvalue doesn't match the property, then we have no tailoring options*/    
        if((sizeof(changemap["stopvalue"]) \> 1) \&\& (Get(NRefOb(\$target[0]), changemap["stopvalue"][0]) != changemap["stopvalue"][1])) \{    
          /* Stopvalue doesn't match. Output error message */    
          if(sizeof(changemap["stopvalue"]) \> 2) \{    
            EmitTo(\$actor, changemap["stopvalue"][2]);    
          \} else \{    
            EmitTo(\$actor, Describe(\$target[0], nil, \$actor) + " already has a modification of that type.");    
          \}    
          return FALSE;    
        \}    
      \}    
    \}    
    
    /* Output valid options */    
    valid_options = map_indices(changemap);    
    if(changemap["input-list-actor"])    
    \{    
      for(counter = 0; counter \< sizeof(changemap["input-list-actor"]); counter++)    
      \{    
        if(Get(\$actor, changemap["input-list-actor"][counter]) \&\& map_indices(Get(\$actor, changemap["input-list-actor"][counter])))    
        \{    
          valid_options += map_indices(Get(\$actor, changemap["input-list-actor"][counter]));    
        \}    
      \}    
    \}    
    if(changemap["input-list"])    
    \{    
      for(counter = 0; counter \< sizeof(changemap["input-list"]); counter++)    
      \{    
        if(Get(changemap["input-list"][counter][0], changemap["input-list"][counter][1]) \&\& map_indices(Get(changemap["input-list"][counter][0], changemap["input-list"][counter][1])))    
        \{    
          valid_options += map_indices(Get(changemap["input-list"][counter][0], changemap["input-list"][counter][1]));    
        \}    
      \}    
    \}    
    
    /* Remove results that aren't options */    
    valid_options -= blocklist;    
    
    /* Put options in alphabetical order */    
    valid_options = map_indices(arr_to_set(valid_options));    
    
    tmp_string = "Valid options are: ";    
    for(counter = 0; counter \< sizeof(valid_options); counter++)    
    \{    
      tmp_string += "\\"" + valid_options[counter] + "\\" ";    
    \}    
    EmitTo(\$actor, "That is not valid input to " + \$modification + " " + Describe(\$target[0], nil, \$actor));    
    EmitTo(\$actor, tmp_string);    
    return FALSE;    
  \}    
\}    
    
/* We have valid input for this modification */    
    
/* Check that this modification hasn't already been made */    
if(changemap["stopvalue"]) \{    
  /* We have a stopvalue. Check if we are allowed to continue */    
  /* If this property exists in the object, then we need to stop, unless it matches the value */    
  if(Get(NRefOb(\$target[0]), changemap["stopvalue"][0])) \{    
    /* if stopvalue doesn't match the property, then exit with message*/    
    if((sizeof(changemap["stopvalue"]) \> 1) \&\& (Get(NRefOb(\$target[0]), changemap["stopvalue"][0]) != changemap["stopvalue"][1])) \{    
      /* Stopvalue doesn't match. Output error message */    
      if(sizeof(changemap["stopvalue"]) \> 2) \{    
        EmitTo(\$actor, changemap["stopvalue"][2]);    
      \} else \{    
        EmitTo(\$actor, Describe(\$target[0], nil, \$actor) + " already has a modification of that type.");    
      \}    
      return FALSE;    
    \}    
  \}    
\}    
    
/* Check if the actor is carrying any necessary tools */    
if(\$tmp = changemap2["requiredtools"])    
\{    
  /*We require tools*/    
  for(counter=1; counter\<sizeof(\$tmp); counter++)    
  \{    
    /*We need a tool*/    
    \$found = nil;    
    for(\$i = 0; (\$i \< sizeof(\$tmp[counter]))\&\&(!\$found); \$i++)    
    \{    
      /*We need a tool of type \$tmp[counter][\$i] */    
      for(\$j = 0; (\$j \< sizeof(\$actor."base:inventory"))\&\&(!\$found); \$j++)    
      \{    
        if(\$actor."base:inventory"[\$j]."trait:objecttype" == \$tmp[counter][\$i])    
        \{    
          /*We found the tool!*/    
          \$found = 1;    
        \}    
      \}    
      /* We didn't find the tool in our inventory. Is the player "using" the tool? */    
      if(!\$found \&\& \$using)    
      \{    
        for(\$j=0; (\$j \< sizeof(\$using))\&\&(!\$found); \$j++)    
        \{    
          if(NRefOb(\$using[\$j])."trait:objecttype" == \$tmp[counter][\$i])    
          \{    
            /*We found the tool!*/    
            /* make sure someone else isn't holding it */    
            if(NRefOb(\$using[\$j])."base:environment"."base:volition")    
            \{    
              EmitTo(\$actor, "You can't use a tool that's being held by someone else.");    
              return FALSE;    
            \} else \{    
              \$found = 1;    
            \}    
          \}    
        \}    
      \}    
    \}    
    /* If we are missing a tool we need */    
    if(!\$found)    
    \{    
      EmitTo(\$actor, "You can't "+\$modification+" "+Describe(\$target[0], nil, \$actor)+" without "+\$tmp[0]+".");    
      return FALSE;    
    \}    
  \}    
\}    
    
/* -------------------------------------------------------------------------*/    
/* -------------------------------------------------------------------------*/    
/* -------------------------------------------------------------------------*/    
    
/* Check if we should decrease the quantity of our original object */    
if(changemap2["cost"]) \{    
  \$cost = changemap2["cost"][0];    
\} else if(changemap["cost"]) \{    
  \$cost = changemap["cost"][0];    
\}    
    
if(\$cost == 0) \$cost = nil;    
    
if(\$cost)    
\{    
  if(NRefOb(\$target[0])."trait:quantity" \&\& NRefOb(\$target[0])."trait:quantity" \> \$cost)    
  \{    
    NRefOb(\$target[0])."trait:quantity" -= \$cost;    
    \$cost = nil;    
  \}    
\}    
    
    
if(\$cost)    
\{    
  if(changemap2["cost"] \&\& (sizeof(changemap2["cost"]) \> 1)) \{    
    \$message = changemap2["cost"][1];    
  \} else if(changemap["cost"] \&\& (sizeof(changemap["cost"]) \> 1)) \{    
    \$message = changemap["cost"][1];    
  \} else \{    
    \$message = "You haven't got enough remaining of "+Describe(\$target[0], nil, \$actor)+" to make this.";    
  \}    
    
  \$message = replace_strings(\$message, "ORIGINAL_OBJECT", Describe(\$target[0], nil, \$actor));    
  EmitTo(\$actor, \$message);    
    
  return FALSE;    
\}    
    
/* -------------------------------------------------------------------------*/    
/* -------------------------------------------------------------------------*/    
/* -------------------------------------------------------------------------*/    
    
/* Check if this turns the object into a new object */    
if(((changemap2["newobject"]) \&\& (new_object = Spawn(changemap2["newobject"]))) \|\| ((changemap["newobject"]) \&\& (new_object = Spawn(changemap["newobject"]))))    
\{    
  new_object."base:environment" = Get(NRefOb(\$target[0]), "base:environment");    
/* If this is a new object, check what properties we should copy from the existing object */    
  if(changemap["newobject-properties"]) \{    
    /* loop through the properties, adding each one */    
    for(counter = 0; counter \< sizeof(changemap["newobject-properties"]); counter++) \{    
      Set(new_object, changemap["newobject-properties"][counter][1], Get(NRefOb(\$target[0]), changemap["newobject-properties"][counter][0]));    
    \}    
  \}    
  /* And again for changemap 2 */    
  if(changemap2["newobject-properties"]) \{    
    /* loop through the properties, adding each one */    
    for(counter = 0; counter \< sizeof(changemap2["newobject-properties"]); counter++) \{    
      Set(new_object, changemap2["newobject-properties"][counter][1], Get(NRefOb(\$target[0]), changemap2["newobject-properties"][counter][0]));    
    \}    
  \}    
\} else \{    
  new_object = NRefOb(\$target[0]);    
\}    
    
/* Check if we need to copy new properties to the object */    
if(changemap["properties"]) \{    
  /* loop through the properties, adding each one */    
  for(counter = 0; counter \< sizeof(changemap["properties"]); counter++) \{    
    /* Do we have a value specified? */    
    if(sizeof(changemap["properties"][counter]) \> 1)    
    \{    
      Set(new_object, changemap["properties"][counter][0], changemap["properties"][counter][1]);    
    \} else \{    
      /* Otherwise, use the modification description */    
      if(changemap2["value"]) \{    
        Set(new_object, changemap["properties"][counter][0], changemap2["value"]);    
      \} else if(changemap2["brief"]) \{    
        Set(new_object, changemap["properties"][counter][0], changemap2["brief"]);    
      \}    
    \}    
  \}    
\}    
/* And again for changemap 2 */    
if(changemap2["properties"]) \{    
  /* loop through the properties, adding each one */    
  for(counter = 0; counter \< sizeof(changemap2["properties"]); counter++) \{    
    /* Do we have a value specified? */    
    if(sizeof(changemap2["properties"][counter]) \> 1)    
    \{    
      Set(new_object, changemap2["properties"][counter][0], changemap2["properties"][counter][1]);    
    \} else \{    
      /* Otherwise, use the modification description */    
      if(changemap2["value"]) \{    
        Set(new_object, changemap2["properties"][counter][0], changemap2["value"]);    
      \} else if(changemap2["brief"]) \{    
        Set(new_object, changemap2["properties"][counter][0], changemap2["brief"]);    
      \}    
    \}    
  \}    
\}    
    
/* Check if we should make a skill roll, to see if the quality changes */    
if((tmp_string = changemap2["skill"]) \|\| (tmp_string = changemap["skill"]))    
\{    
  counter = Call(\$\{IronClaw:Lib:UrPeople:System\}, "roll", \$dicearray: (\{ \$actor."trait:mind", Get(\$actor, "skill:alteration:"+tmp_string), Get(\$actor, "career:alteration:"+tmp_string) \}) );    
  if(!new_object."trait:quality") new_object."trait:quality" = 4;    
  if(counter \> new_object."trait:quality") \{    
    new_object."trait:quality"++;    
  \} else if(counter \< new_object."trait:quality") \{    
    new_object."trait:quality"--;    
  \}    
\}    
    
/* Output an appropriate description of the action */    
    
/* Generate the descriptions */    
if((changemap["description"] \&\& sizeof(changemap["description"]) \> 1) \|\| (changemap2["description"] \&\& sizeof(changemap2["description"]) \> 1)) \{    
  /* properties for the 1st person and 3rd person description */    
  string description1;    
  string description3;    
    
  if(changemap2["description"] \&\& (sizeof(changemap2["description"]) \> 1)) \{    
    description1 = changemap2["description"][0];    
    description3 = Describe(\$actor) +" "+ changemap2["description"][1];    
  \} else \{    
    description1 = changemap["description"][0];    
    description3 = Describe(\$actor) +" "+ changemap["description"][1];    
  \}    
    
  /* replace keywords */    
  if(changemap2["brief"])    
  \{    
    description1 = replace_strings(description1, "BRIEF", changemap2["brief"]);    
    description3 = replace_strings(description3, "BRIEF", changemap2["brief"]);    
  \}    
  description1 = replace_strings(description1, "ORIGINAL_OBJECT", Describe(\$target, nil, \$actor));    
  description1 = replace_strings(description1, "NEW_OBJECT", Describe(new_object, nil, \$actor, STYLE_NONPOSS));    
  description1 = replace_strings(description1, "PRONOUN", \$actor."base:pronoun");    
  description1 = replace_strings(description1, "POSSESSIVE", \$actor."base:possessive");    
    
  description3 = replace_strings(description3, "ORIGINAL_OBJECT", Describe(\$target, \$actor));    
  description3 = replace_strings(description3, "NEW_OBJECT", Describe(new_object, \$actor, nil, STYLE_NONPOSS));    
  description3 = replace_strings(description3, "PRONOUN", \$actor."base:pronoun");    
  description3 = replace_strings(description3, "POSSESSIVE", \$actor."base:possessive");    
    
  /* Check what the modification is, for the description */    
  if(changemap2["modification"])    
  \{    
    description1 = replace_strings(description1, "MODIFICATION", changemap2["modification"]);    
    description3 = replace_strings(description3, "MODIFICATION", changemap2["modification"]);    
  \} else if(changemap["modification"]) \{    
    description1 = replace_strings(description1, "MODIFICATION", changemap["modification"]);    
    description3 = replace_strings(description3, "MODIFICATION", changemap["modification"]);    
  \}    
    
  /* Should add an evoke, if any, to the end of the description */    
  if(\$evoke) \{    
    description1 += ", " + \$evoke;    
    description3 += ", " + \$evoke;    
  \} else \{    
    description1 += ".";    
    description3 += ".";    
  \}    
    
  EmitTo(\$actor, description1);    
  EmitIn(\$actor."base:environment", description3, \$actor);    
    
  /* Slay the original object, if appropriate */    
  if((changemap["newobject"] \|\| changemap2["newobject"]) \&\& (!(changemap["noslay"]) \|\| (changemap["noslay"] == "false")) \&\& (!(changemap2["noslay"]) \|\| (changemap2["noslay"] == "false")))    
  \{    
    Slay(NRefOb(\$target[0]));    
  \}    
    
  return FALSE;    
\} else \{    
  /* Slay the original object, if appropriate */    
  if((changemap["newobject"] \|\| changemap2["newobject"]) \&\& (!(changemap["noslay"]) \|\| (changemap["noslay"] == "false")) \&\& (!(changemap2["noslay"]) \|\| (changemap2["noslay"] == "false")))    
  \{    
    Slay(NRefOb(\$target[0]));    
  \}    
    
  return TRUE;    
\}
      </Core:Property>
      <Core:Property property="merry:lib:replaceadj">
         X[M] string * words;    
int i;    
\$actor = nil /* defunct */;    
if(!\$object) return FALSE;    
if(!\$detail) \$detail = "default";    
    
/* remove plain as an adjective */    
\$object."details:default:adjective:plain" = nil;    
    
/* remove old adjective */    
if(\$(hook-oldvalue)) \{    
  words = explode(\$(hook-oldvalue), " ");    
  for(i = 0; i \< sizeof(words); i++)    
  \{    
    Set(\$object, "details:"+\$detail+":adjective:" + words[i], nil);    
  \}    
\}    
/* add new adjective */    
if(!Get(\$object, \$(hook-property))) return TRUE;    
words = explode(Get(\$object, \$(hook-property)), " ");    
for(i = 0; i \< sizeof(words); i++)    
\{    
  Set(\$object, "details:"+\$detail+":adjective:" + words[i], 1);    
\}    
return TRUE;
      </Core:Property>
      <Core:Property property="merry:lib:replacesname">
         X[M] string * words;    
int i;    
    
if(!\$object) return FALSE;    
    
/* remove old adjective */    
if(\$(hook-oldvalue)) \{    
  words = explode(\$(hook-oldvalue), " ");    
  for(i = 0; i \< sizeof(words); i++)    
  \{    
    Set(\$object, "details:default:sname:" + words[i], nil);    
  \}    
\}    
/* add new adjective */    
if(!\$(hook-property)) return TRUE;    
if(!Get(\$object, \$(hook-property))) return TRUE;    
words = explode(Get(\$object, \$(hook-property)), " ");    
for(i = 0; i \< sizeof(words); i++)    
\{    
  Set(\$object, "details:default:sname:" + words[i], 1);    
\}    
return TRUE;
      </Core:Property>
      <Core:Property property="merry:lib:valid-check">
         X[M] /*EmitTo(\$actor, "Args = " + dump_value(args));*/    
/* Check if we were given a direct object to add to the indirect object */    
/* Check if we were given a \$addition to add to the \$object */    
if(!\$addition) \{    
return TRUE;    
\}    
    
if(!\$object[0])    
\{    
  return FALSE;    
\}    
    
/* check we were only given one direct object */    
if(sizeof(\$addition) \> 1) \{    
  EmitTo(\$actor, "You can only add one object at a time");    
  return FALSE;    
\}    
    
/* this check should also be in the object being added */    
if(sizeof(\$object) \> 1) \{    
  EmitTo(\$actor, "You can only add to one object at a time");    
  return FALSE;    
\}    
    
/* Check if we are allowed to add the addition to the object */    
/*EmitTo(\$actor, "Adding " + Describe(\$addition) + " to " + Describe(\$object));*/    
if(!(Get(NRefOb(\$object[0]), "alteration:add:" + NRefDetail(\$object[0]) + ":" + Str(Get(NRefOb(\$addition[0]), "trait:objecttype")))))    
\{    
  EmitTo(\$actor, "You can't combine these objects");    
  return FALSE;    
\}    
    
/* We can combine the objects */    
return TRUE;
      </Core:Property>
      <Core:Property property="merry:react-post:add-iob">
         X[M] return Call(\$\{Ironclaw:Lib:Crafting:Lib\}, "add", \$addition: \$dob, \$target: \$iob);
      </Core:Property>
      <Core:Property property="merry:react-pre:add-iob">
         X[M] if(!\$dob) return TRUE;    
return Call(\$\{Ironclaw:Lib:Crafting:Lib\}, "valid-check", \$addition: \$dob, \$object: \$iob);
      </Core:Property>
      <Core:Property property="merry:react-pre:paint-iob">
         X[M] if((sizeof(Match(\$actor, "paint")) == 0) \&\& (sizeof(Match(\$actor, "paintbrush")) == 0)) \{                       
  EmitTo(\$actor, "You need a paintbrush and some paint.");                       
  return FALSE;                       
\} else if(sizeof(Match(\$actor, "paintbrush")) == 0) \{                       
  EmitTo(\$actor, "You need a paintbrush.");                       
  return FALSE;                       
\} else if(sizeof(Match(\$actor, "paint")) == 0) \{                       
  EmitTo(\$actor, "You need some paint.");                       
  return FALSE;                       
\}      
 
if(\$this."base:environment" != \$actor) \{ 
  EmitTo(\$actor, "You must be holding " + Describe(\$this, nil, \$actor) + " to paint on it."); 
  return FALSE; 
\} 
 
return TRUE;
      </Core:Property>
      <Core:Property property="merry:react:paint-iob">
         X[M] if(\$dob \&\& NRefOb(\$dob[0])) \{ 
    Call(\$\{Allegory:Lib:Crafting:Custom:Painting\}, "paint", \$item: \$this, \$brief: Describe(\$dob[0])); 
    return TRUE; 
\} else \{ 
    Popup(\$actor, \$\{Allegory:Lib:Crafting:Custom:Painting\}, "html:index", \$actor: \$actor, \$action: "paint", \$item: Str(\$this), \$using: Str(NRefOb(\$using[0]))); 
\}
      </Core:Property>
      <Core:Property property="merry:setprop-post:trait:gem:material">
         X[M] if(!\$this."trait:gem:material") return TRUE;          
Set(\$this, "details:gem:sname:" +Str(\$this."trait:gem:material")+ ":local", 1);          
Set(\$this, "details:gem:sname:gem:local", 1);          
          
return Call(\$\{Ironclaw:Lib:Crafting:Lib\}, "replaceadj", \$object: this);
      </Core:Property>
      <Core:Property property="merry:setprop-post:trait:material">
         X[M] return Call(\$\{Ironclaw:Lib:Crafting:Lib\}, "replaceadj", \$object: this);
      </Core:Property>
      <Core:Property property="merry:setprop-post:trait:shape">
         X[M] return Call(\$\{Ironclaw:Lib:Crafting:Lib\}, "replaceadj", \$object: this);
      </Core:Property>
      <Core:Property property="merry:setprop-post:trait:type">
         X[M] return Call(\$\{Ironclaw:Lib:Crafting:Lib\}, "replaceadj", \$object: this);
      </Core:Property>
      <Core:Property property="revisions">
         (\{ 1539818884, "jominey", "E", 1539818914, "jominey", "E", 1539819491, "jominey", "K", 1539827804, "jominey", "E", 1539827809, "jominey", "E", 1614556780, "sendnoodlez", "E", 1614556784, "sendnoodlez", "E", 1630650775, "ezralee", "K", 1642027851, "sendnoodlez", "E", 1642027886, "sendnoodlez", "X", 1642028399, "sendnoodlez", "E", 1642028523, "sendnoodlez", "X", 1642028575, "sendnoodlez", "E", 1642029431, "sendnoodlez", "E", 1642029962, "sendnoodlez", "E", 1642029997, "sendnoodlez", "E", 1642030040, "sendnoodlez", "E" \})
      </Core:Property>
      <Core:Property property="skill:fatigue">1.0</Core:Property>
      <Core:Property property="volition">0</Core:Property>
    </Core:Properties>
    <Notes:Notes/>
  </Base:Thing>
</object>
