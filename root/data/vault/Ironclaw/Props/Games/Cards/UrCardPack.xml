<object clone="/base/obj/thing" owner="SkotOS">
  <Base:Thing>
    <Ur:UrObject/>
    <Base:Bulk immobile="false" mass="0.2" density="0.1"/>
    <Base:Container flexible="false" transparent-container="false" public-container="false" tight="false" capacity="0" maxweight="0"/>
    <Base:Misc gender="neuter" volition="false" weapon="false" default_stance="none" combinable="false" discrete="false" by_weight="false" tight="false" scriptrunner="false">
      <Base:Edible value="false"/>
      <Base:Potable value="false"/>
      <Base:DrinkMessageFirst></Base:DrinkMessageFirst>
      <Base:DrinkMessageThird></Base:DrinkMessageThird>
      <Base:Transparency value="false"/>
      <Base:Unsafe value="false"/>
      <Base:Safe value="false"/>
      <Base:ClothesExpected value="false"/>
      <Base:DieMessageFirst></Base:DieMessageFirst>
      <Base:DieMessageThird></Base:DieMessageThird>
    </Base:Misc>
    <Base:Details>
      <Base:Detail id="default" prime="true" def="false" abstract="false" hidden="false" luminosity="0" targetable_in_dark="false" plural="false">
        <Base:Preposition close="false" against="false" under="false" on="false" inside="false" near="false" over="false" behind="false" before="false" beside="false"/>
        <Base:Names>
          <Base:SNames>
            <Base:SName sname="pack"/>
            <Base:SName sname="deck"/>
          </Base:SNames>
          <Base:PNames>
            <Base:PName pname="packs"/>
            <Base:PName pname="cards"/>
            <Base:PName pname="decks"/>
          </Base:PNames>
        </Base:Names>
        <Base:Adjectives>
          <Base:Adjective adjective="card"/>
        </Base:Adjectives>
        <Base:Descriptions>
          <Base:Description type="brief">
             {? equal | $(this.trait:color) | none || $(this.trait:color)} {? equal | $(this.trait:material) | none || $(this.trait:material)} card deck
          </Base:Description>
          <Base:Description type="look">
             A pack of {? equal | $(this.trait:color) | none || $(this.trait:color)} {? equal | $(this.trait:material) | none || $(this.trait:material)} playing cards. Each card features a depiction $(this.trait:design) on the back.
This is a $(this.carddescription).
          </Base:Description>
          <Base:Description type="pbrief">
             card decks
          </Base:Description>
        </Base:Descriptions>
        <Base:Exit door="false" never_obvious="false" obvious_when_open="false" hidden_when_closed="false" separate="false" self-locking="false" deadbolt="false"/>
        <Base:Climbable/>
      </Base:Detail>
      <Base:Detail id="instructions" prime="false" def="true" abstract="false" hidden="false" luminosity="0" targetable_in_dark="false" plural="false">
        <Base:Preposition close="false" against="false" under="false" on="false" inside="false" near="false" over="false" behind="false" before="false" beside="false"/>
        <Base:Names>
          <Base:SNames>
            <Base:SName sname="instructions"/>
          </Base:SNames>
          <Base:PNames>
            <Base:PName pname="instructions"/>
          </Base:PNames>
        </Base:Names>
        <Base:Adjectives/>
        <Base:Descriptions>
          <Base:Description type="brief">
             card instructions
          </Base:Description>
          <Base:Description type="look">
             gather my deck - gathers all the missing cards for the deck, placing them back into the deck<br/>
shuffle my deck - shuffles the cards in the deck<br/>
deal my deck - takes a card from the deck<br/>
deal my deck to [person] - deals a card to another player<br/>
deal my deck '[number] - deals that number of cards<br/>
deal my deck to [person] '[number] - deals that number of cards to another player<br/>
deal my deck rightside-up - displays what cards are drawn when dealing<br/>
deal my deck upside-down - hides which cards are drawn when dealing<br/>
strip my deck '[criteria] - goes through the deck, removing specified cards.<br/>
criteria when stripping a deck can be numbers or words. For example you can "strip my deck 'queen" to remove all queens, or "strip my deck '3" to remove all 3's. You can also "strip my deck 'three" to remove all threes. Specifically named cards can also be stripped from a deck.<br/>
 <br/>
commands for the cards:<br/>
reveal my card - shows other players what the card is<br/>
conceal my card - stops showing what the card is<br/>
scan my cards - lists the cards in suit order, including a number so players know which card is which when targetting (i.e. the card with number 4 is "my fourth card")<br/>
place my card on deck - puts the card on the top of the deck<br/>
place my card under deck - puts the card on the bottom of the deck<br/>
shuffle my card into deck - shuffles the card into the deck<br/>
note: cards from different packs can be shuffled into a deck. This allows players to create double decks, etc.<br/>
          </Base:Description>
          <Base:Description type="writing">
             gather my deck - gathers all the missing cards for the deck, placing them back into the deck<br/>
shuffle my deck - shuffles the cards in the deck<br/>
deal my deck - takes a card from the deck<br/>
deal my deck to [person] - deals a card to another player<br/>
deal my deck '[number] - deals that number of cards<br/>
deal my deck to [person] '[number] - deals that number of cards to another player<br/>
deal my deck rightside-up - displays what cards are drawn when dealing<br/>
deal my deck upside-down - hides which cards are drawn when dealing<br/>
strip my deck '[criteria] - goes through the deck, removing specified cards.<br/>
criteria when stripping a deck can be numbers or words. For example you can "strip my deck 'queen" to remove all queens, or "strip my deck '3" to remove all 3's. You can also "strip my deck 'three" to remove all threes. Specifically named cards can also be stripped from a deck.<br/>
 <br/>
commands for the cards:<br/>
reveal my card - shows other players what the card is<br/>
conceal my card - stops showing what the card is<br/>
scan my cards - lists the cards in suit order, including a number so players know which card is which when targetting (i.e. the card with number 4 is "my fourth card")<br/>
place my card on deck - puts the card on the top of the deck<br/>
place my card under deck - puts the card on the bottom of the deck<br/>
shuffle my card into deck - shuffles the card into the deck<br/>
note: cards from different packs can be shuffled into a deck. This allows players to create double decks, etc.<br/>
          </Base:Description>
        </Base:Descriptions>
        <Base:Exit door="false" never_obvious="false" obvious_when_open="false" hidden_when_closed="false" separate="false" self-locking="false" deadbolt="false"/>
        <Base:Climbable/>
      </Base:Detail>
    </Base:Details>
    <Base:Combat>
      <Base:Strength value="1"/>
      <Base:MaxFatigue value="1"/>
    </Base:Combat>
    <Base:Clothing>
      <Base:SingleWear value="false"/>
    </Base:Clothing>
    <Base:Crafting see_level="0" do_level="0" time="0" attention="false" held="false">
      <Base:Ingredients/>
      <Base:Tools/>
      <Base:CraftVerbs/>
    </Base:Crafting>
    <Base:InitialContents/>
    <Base:InitialProperties/>
    <Core:Properties>
      <Core:Property property="export:bottomcards"/>
      <Core:Property property="export:card">
         \<Ironclaw:Props:Games:Cards:UrCard\>
      </Core:Property>
      <Core:Property property="export:carddeck">1</Core:Property>
      <Core:Property property="export:carddescription">
         "single deck of cards, with both jokers"
      </Core:Property>
      <Core:Property property="export:deck">
         \<Ironclaw:Props:Games:Cards:Decks:Default\>
      </Core:Property>
      <Core:Property property="export:mixedcards"/>
      <Core:Property property="export:nip:item:cost">
         1200
      </Core:Property>
      <Core:Property property="export:playingcards">
         (\{ "H1", "H2", "H3", "H4", "H5", "H6", "H7", "H8", "H9", "H10", "H11", "H12", "H13", "D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8", "D9", "D10", "D11", "D12", "D13", "C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8", "C9", "C10", "C11", "C12", "C13", "S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8", "S9", "S10", "S11", "S12", "S13", "J1", "J2" \})
      </Core:Property>
      <Core:Property property="export:topcards"/>
      <Core:Property property="export:trait:dealable">
         1
      </Core:Property>
      <Core:Property property="log:creator">"Azrael"</Core:Property>
      <Core:Property property="merry:act:start">
         X[M] \$this."alteration:color:desc" = oneof ("aquamarine", "ice blue", "steel-gray", "steel-blue", "royal blue", "midnight blue", "shimmering pale blue", "glossy chalcedony blue", "sparkling azure", "emerald", "jade", "dazzling dioptase green", "grass green", "fresh green", "ruby red", "cardinal red", "vermilion", "burgundy", "cerise", "garnet", "lustrous garnet", "wine", "dusky wine", "sparkling scarlet", "cherry blossom pink", "shimmering pink", "glossy rose colored", "copper rose", "copper-colored", "bronze-colored", "silvery", "silvery white", "golden", "honey-colored", "gleaming gold", "bright amber", "vivid saffron", "persimmon", "coral-colored", "dark chocolate", "chocolate", "cinnamon", "caramel", "tyrian purple", "pearly lilac", "imperial purple", "obsidian black", "shimmering raven", "alabaster", "snow white", "frosted white", "glimmering white", "pure white", "seashell white", "misty rose", "smoky gray", "storm gray", "dove gray", "swan white", "sunburst") ; 
\$this."trait:color" = \$this."alteration:color:desc" ;  
 
return TRUE;
      </Core:Property>
      <Core:Property property="merry:react-pre:deal-what">
         X[M] int i;   
   
/* are we switching how we deal cards? */   
if(!\$evoke \&\& \$adverb) \{   
  if(\$adverb == "upside-down") \{   
    EmitTo(\$actor, "You will now deal cards from this deck face-side downwards.");   
    \$this.faceup = nil;   
    return FALSE;   
  \} else if(\$adverb == "rightside-up") \{   
    EmitTo(\$actor, "You will now deal cards from this deck with the face-side displaying.");   
    \$this.faceup = TRUE;   
    return FALSE;   
  \}   
\}   
   
/* do we have any cards left? */   
if(sizeof(\$this.playingcards) \< 1) \{   
  EmitTo(\$actor, "There are no cards left in the deck to deal.");   
  return FALSE;   
\}   
   
/* how many cards? */   
/* remove nils */   
\$this.topcards -= (\{ nil \});   
\$this.mixedcards -= (\{ nil \});   
\$this.bottomcards -= (\{ nil \});   
if(\$evoke \&\& sscanf(\$evoke, "\\"%d\\"", \$number))\{   
  \$nodelay = TRUE;   
  if(\$number \> (sizeof(\$this.playingcards) + sizeof(\$this.topcards) + sizeof(\$this.mixedcards) + sizeof(\$this.bottomcards))) \$number = sizeof(\$this.playingcards) + sizeof(\$this.topcards) + sizeof(\$this.mixedcards) + sizeof(\$this.bottomcards);   
\} else \{   
  \$number = 1;   
\}   
   
/* who to? */   
if(\$iob) \{   
  \$vic = NRefOb(Arr(\$iob)[0]);   
\} else \{   
  \$vic = \$actor;   
\}   
   
/* do we add cards to the pile? */   
if(Get(\$this, "dealing:"+name(\$vic))) \{   
  \$addtopile = TRUE;   
\}   
   
/* deal the cards */   
if(!\$this.missingcards) \$this.missingcards = (\{ \});   
for(i=0;i\<\$number;i++) \{   
  /* do we have a top card? */   
  if(sizeof(\$this.topcards)) \{   
    /* give them the top card */   
    \$card = \$this.topcards[0];   
    \$this.topcards -= (\{ \$card \});   
  \} else if(!sizeof(\$this.playingcards) \&\& !sizeof(\$this.mixedcards)) \{   
    /* there are no random cards, give them a card from the bottom */   
    \$card = \$this.bottomcards[0];   
    \$this.bottomcards -= (\{ \$card \});   
  \} else \{   
    /* give them a shuffled card */   
    /* should we get one from the mixed array? */   
    if(sizeof(\$this.mixedcards) \&\& random(sizeof(\$this.playingcards) + sizeof(\$this.mixedcards)) \< sizeof(\$this.mixedcards)) \{   
      /* give one from the mixed array */   
      \$card = \$this.mixedcards[random(sizeof(\$this.mixedcards))];   
      \$this.topcards -= (\{ \$card \});   
    \} else \{   
      \$card = Spawn(\$this.card);   
      \$card.deck = \$this.deck;   
      /* which card? */   
      \$card.card = \$this.playingcards[random(sizeof(\$this.playingcards))];   
      /* remove that card from this deck */   
      \$this.playingcards = copy(\$this.playingcards);   
      \$this.playingcards -= (\{ \$card.card \});   
      \$this.missingcards += (\{ \$card \});   
    \}   
  \}   
  \$card."base:environment" = \$vic;   
  if(\$this.faceup \|\| (\$adverb \&\& \$adverb == "rightside-up") ) \{   
    \$card.revealed = TRUE;   
  \}   
  /* mark these cards */   
  if(Get(\$this, "dealing:"+name(\$vic))) \{   
    \$tmp = Get(\$this, "dealing:"+name(\$vic));   
    \$tmp += (\{ NewNRef(\$card, "default") \});   
    Set(\$this, "dealing:"+name(\$vic), \$tmp);   
  \} else \{   
    Set(\$this, "dealing:"+name(\$vic), (\{ NewNRef(\$card, "default") \}));   
  \}   
   
\}   
   
if(\$addtopile) return FALSE;   
   
if(!\$nodelay)   
  \$delay(4.0, FALSE, "75d3");   
   
/* who to? */   
if(\$iob) \{   
  EmitTo(\$actor, "You deal "+Describe(Get(\$this, "dealing:"+name(\$vic)), nil, nil, STYLE_NONPOSS)+" to "+Describe(Arr(\$iob)[0])+".");   
  EmitTo(\$vic, Describe(\$actor)+" deals "+Describe(Get(\$this, "dealing:"+name(\$vic)), nil, \$actor, STYLE_NONPOSS)+" to you.");   
  EmitIn(\$actor."base:environment", Describe(\$actor)+" deals "+Describe(Get(\$this, "dealing:"+name(\$vic)), nil, nil, STYLE_NONPOSS)+" to "+Describe(Arr(\$iob)[0])+".", \$actor, \$vic);   
  Set(\$this, "dealing:"+name(\$vic), nil);   
\} else \{   
  EmitTo(\$actor, "You draw "+Describe(Get(\$this, "dealing:"+name(\$vic)), nil, \$actor, STYLE_NONPOSS)+" from "+Describe(\$this, nil, \$actor)+".");   
  EmitIn(\$actor."base:environment", Describe(\$actor)+" draws "+Describe(Get(\$this, "dealing:"+name(\$vic)), nil, nil, STYLE_NONPOSS)+" from "+Describe(\$this, \$actor)+".", \$actor);   
  Set(\$this, "dealing:"+name(\$vic), nil);   
\}   
   
return FALSE;
      </Core:Property>
      <Core:Property property="merry:react:gather-dob">
         X[M] int i, sz;  
object holder;  
/* is this held by someone else? */  
holder = \$this;  
while(holder \&\& holder."base:environment") \{  
  holder = holder."base:environment";  
  if(holder.volition \&\& holder != \$actor) \{  
    EmitTo(\$actor, "You must be holding "+Describe(\$this)+" to gather it.");  
    return FALSE;  
  \}  
\}  
  
if(\$this.missingcards \&\& sizeof(\$this.missingcards)) \{  
  EmitTo(\$actor, "You gather up the missing cards from "+Describe(\$this, nil, \$actor)+".");  
  EmitIn(\$actor."base:environment", Describe(\$actor)+" gathers up the missing cards from "+Describe(\$this, \$actor)+".", \$actor);  
  /* slay the missing cards */  
  if(\$this.missingcards) \{  
    sz = sizeof(\$this.missingcards);  
  \} else \{  
    sz = 0;  
  \}  
  for(i=0;i\<sz;i++)\{  
    if(\$this.missingcards[i])  
      Slay(\$this.missingcards[i]);  
  \}  
\} else \{  
  EmitTo(\$actor, "You already have all the cards in your deck.");  
\}  
\$this.playingcards = nil;  
\$this.missingcards = nil;  
if(\$this.mixedcards \&\& sizeof(\$this.mixedcards)) \$this.mixedcards -= (\{ nil \});  
if(\$this.topcards \&\& sizeof(\$this.topcards)) \$this.topcards -= (\{ nil \});  
if(\$this.bottomcards \&\& sizeof(\$this.bottomcards)) \$this.bottomcards -= (\{ nil \});  
return FALSE;
      </Core:Property>
      <Core:Property property="merry:react:scan-dob">
         X[M] /* don't output this to the room */   
EmitTo(\$actor, "You briefly glance at your deck of cards.");   
return FALSE;
      </Core:Property>
      <Core:Property property="merry:react:shuffle-dob">
         X[M] object holder;  
  
/* is this held by someone else? */  
holder = \$this;  
while(holder \&\& holder."base:environment") \{  
  holder = holder."base:environment";  
  if(holder.volition \&\& holder != \$actor) \{  
    EmitTo(\$actor, "You must be holding "+Describe(\$this)+" to shuffle it.");  
    return FALSE;  
  \}  
\}  
  
/* don't shuffle the cards *into* somewhere */  
if(\$iob)\{  
  if(sizeof(\$dob) == 1)  
    EmitTo(\$actor, "Are you sure you intended to do that?");  
  return FALSE;  
\}  
  
/* shuffle the cards by adding them all to the mixedcards array */  
\$this.mixedcards += \$this.topcards;  
\$this.mixedcards += \$this.bottomcards;  
\$this.mixedcards -= (\{ nil \});  
\$this.topcards = (\{ \});  
\$this.bottomcards = (\{ \});  
return TRUE;
      </Core:Property>
      <Core:Property property="merry:react:strip-dob">
         X[M] int i, sz, j, j_sz;   
string criteria, *removing, *removed_cards, cardinal;   
object *matches;   
object holder;   
   
/* is this held by someone else? */   
holder = \$this;   
while(holder \&\& holder."base:environment") \{   
  holder = holder."base:environment";   
  if(holder.volition \&\& holder != \$actor) \{   
    EmitTo(\$actor, "You must be holding "+Describe(\$this)+" to strip it.");   
    return FALSE;   
  \}   
\}   
   
/* strip cards from the deck */   
   
if(!\$evoke) \{   
  EmitTo(\$actor, "Format: strip my deck 'clubs - will strip the clubs from your deck. You can strip based on suits, and sometimes on named cards.");   
  return FALSE;   
\}   
   
/* what is the keyword we are stripping cards on? */   
criteria = \$evoke[1..strlen(\$evoke)-2];   
   
/* sanity checking */   
if(!\$this.missingcards)   
  \$this.missingcards = (\{ \});   
if(cardinal(criteria) != -1) \{   
  cardinal = Str(cardinal(criteria));   
\} else \{   
  cardinal = nil;   
\}   
   
/* check through all the cards for matches */   
matches = (\{ \});   
/* check the already created cards */   
if(\$this.topcards \&\& sizeof(\$this.topcards)) \{   
  for(i=0;i\<sizeof(\$this.topcards);i++) \{   
    if(\$this.topcards[i]."card:name" \&\& contains(\$this.topcards[i]."card:name", criteria))\{   
      \$this.topcards[i]."base:environment" = \$actor;   
      \$this.mixedcards[i].revealed = TRUE;   
      matches += (\{ NRefOb(\$this.topcards[i]) \});   
      \$this.topcards -= (\{ \$this.topcards[i] \});   
      i--;   
    \}   
  \}   
  if(cardinal) \{   
    for(i=0;i\<sizeof(\$this.topcards);i++) \{   
      if(\$this.topcards[i].card \&\& contains(\$this.topcards[i].card[1..strlen(\$this.topcards[i].card)-1], cardinal))\{   
        \$this.topcards[i]."base:environment" = \$actor;   
        \$this.topcards[i].revealed = TRUE;   
        matches += (\{ NRefOb(\$this.topcards[i]) \});   
        \$this.topcards -= (\{ \$this.topcards[i] \});   
        i--;   
      \}   
    \}   
  \}   
\}   
if(\$this.mixedcards \&\& sizeof(\$this.mixedcards)) \{   
  for(i=0;i\<sizeof(\$this.mixedcards);i++) \{   
    if(\$this.mixedcards[i]."card:name" \&\& contains(\$this.mixedcards[i]."card:name", criteria))\{   
      \$this.mixedcards[i]."base:environment" = \$actor;   
      \$this.mixedcards[i].revealed = TRUE;   
      matches += (\{ NRefOb(\$this.mixedcards[i]) \});   
      \$this.mixedcards -= (\{ \$this.mixedcards[i] \});   
      i--;   
    \}   
  \}   
  if(cardinal) \{   
    for(i=0;i\<sizeof(\$this.mixedcards);i++) \{   
      if(\$this.mixedcards[i].card \&\& contains(\$this.mixedcards[i].card[1..strlen(\$this.mixedcards[i].card)-1], cardinal))\{   
        \$this.mixedcards[i]."base:environment" = \$actor;   
        \$this.mixedcards[i].revealed = TRUE;   
        matches += (\{ NRefOb(\$this.mixedcards[i]) \});   
        \$this.mixedcards -= (\{ \$this.mixedcards[i] \});   
        i--;   
      \}   
    \}   
  \}   
\}   
if(\$this.bottomcards \&\& sizeof(\$this.bottomcards)) \{   
  for(i=0;i\<sizeof(\$this.bottomcards);i++) \{   
    if(\$this.bottomcards[i]."card:name" \&\& contains(\$this.bottomcards[i]."card:name", criteria))\{   
      \$this.bottomcards[i]."base:environment" = \$actor;   
      \$this.bottomcards[i].revealed = TRUE;   
      matches += (\{ NRefOb(\$this.bottomcards[i]) \});   
      \$this.bottomcards -= (\{ \$this.bottomcards[i] \});   
      i--;   
    \}   
  \}   
  if(cardinal) \{   
    for(i=0;i\<sizeof(\$this.bottomcards);i++) \{   
      if(\$this.bottomcards[i].card \&\& contains(\$this.bottomcards[i].card[1..strlen(\$this.bottomcards[i].card)-1], cardinal))\{   
        \$this.bottomcards[i]."base:environment" = \$actor;   
        \$this.bottomcards[i].revealed = TRUE;   
        matches += (\{ NRefOb(\$this.bottomcards[i]) \});   
        \$this.bottomcards -= (\{ \$this.bottomcards[i] \});   
        i--;   
      \}   
    \}   
  \}   
\}   
   
/* check the uncreated cards */   
if(\$this.deck) \{   
  \$deck = \$this.deck;   
  removed_cards = (\{ \});   
  /* check the cards based on number */   
  if(cardinal) \{   
    sz = sizeof(\$this.playingcards);   
    for(i=0;i\<sz;i++) \{   
      if(\$this.playingcards[i][1..strlen(\$this.playingcards[i])-1] == cardinal)   
        removed_cards += (\{ \$this.playingcards[i] \});   
    \}   
    \$this.playingcards -= (\{ nil \});   
  \}   
  /* check the cards based on suit */   
  if(\$deck.suits) \{   
    removing = (\{ \});   
    sz = sizeof(map_indices(\$deck.suits));   
    for(i=0;i\<sz;i++)\{   
      if(contains(\$deck.suits[map_indices(\$deck.suits)[i]], criteria)) \{   
        removing += (\{ map_indices(\$deck.suits)[i] \});   
      \}   
    \}   
    /* now remove these suits */   
    sz = sizeof(\$this.playingcards);   
    for(i=0;i\<sz;i++) \{   
      j_sz = sizeof(removing);   
      for(j=0;j\<j_sz;j++) \{   
        if(\$this.playingcards[i][0..0] == removing[j])   
          removed_cards += (\{ \$this.playingcards[i] \});   
      \}   
    \}   
    \$this.playingcards -= (\{ nil \});   
  \}   
  /* check the cards based on name */   
  if(\$deck.names) \{   
    removing = (\{ \});   
    sz = sizeof(map_indices(\$deck.names));   
    for(i=0;i\<sz;i++)\{   
      if(contains(Str(\$deck.names[map_indices(\$deck.names)[i]]), criteria)) \{   
        removing += (\{ Str(map_indices(\$deck.names)[i]) \});   
      \}   
    \}   
    /* now remove these names */   
    sz = sizeof(\$this.playingcards);   
    for(i=0;i\<sz;i++) \{   
      j_sz = sizeof(removing);   
      for(j=0;j\<j_sz;j++) \{   
        if(\$this.playingcards[i][1..strlen(\$this.playingcards[i])-1] == removing[j])   
          removed_cards += (\{ \$this.playingcards[i] \});   
      \}   
    \}   
    \$this.playingcards -= (\{ nil \});   
  \}   
  /* check the cards based on unique name */   
  sz = sizeof(\$this.playingcards);   
  for(i=0;i\<sz;i++) \{   
    if(Get(\$deck, "name:"+\$this.playingcards[i]) \&\& contains(Get(\$deck, "name:"+\$this.playingcards[i]), criteria))   
      removed_cards += (\{ \$this.playingcards[i] \});   
  \}   
  \$this.playingcards -= (\{ nil \});   
   
  /* create the cards, and move them to the player */   
  sz = sizeof(removed_cards);   
  for(i=0;i\<sz;i++) \{   
    \$card = Spawn(\$this.card);   
    \$card.deck = \$this.deck;   
    \$card.revealed = TRUE;   
    /* which card? */   
    \$card.card = removed_cards[i];   
   
    /* remove that card from this deck */   
    matches += (\{ \$card \});   
    \$card."base:environment" = \$actor;   
    \$this.playingcards = copy(\$this.playingcards);   
    \$this.playingcards -= (\{ \$card.card \});   
    \$this.missingcards += (\{ \$card \});   
  \}   
\}   
   
/* display the stripping */   
if(!sizeof(matches)) \{   
  EmitTo(\$actor, "You find no cards to strip from the deck.");   
  return FALSE;   
\}   
   
EmitTo(\$actor, "You strip "+Describe(matches, nil, nil, STYLE_NONPOSS)+" from "+Describe(\$this, nil, \$actor)+".");   
EmitIn(\$actor."base:environment", Describe(\$actor)+" strips "+Describe(matches, nil, nil, STYLE_NONPOSS)+" from "+Describe(\$this, \$actor)+".", \$actor);   
   
return FALSE;
      </Core:Property>
      <Core:Property property="revisions">
         (\{ 1176124568, "tonyd", "E", 1176124594, "tonyd", "P", 1176126041, "tonyd", "P", 1176126098, "tonyd", "P", 1211154103, "tonyd", "E", 1211154119, "tonyd", "E", 1211154123, "tonyd", "E", 1211154134, "tonyd", "E", 1211154157, "tonyd", "E", 1211154173, "tonyd", "E", 1211154270, "tonyd", "E", 1211154358, "tonyd", "E", 1237016860, "tonyd", "E", 1248746553, "rastalabor", "X", 1248746699, "rastalabor", "X", 1250482945, "jominey", "E", 1275456131, "tonyd", "E", 1277839497, "slurpeeslurp", "E", 1277839810, "slurpeeslurp", "E", 1315673280, "slurpeeslurp", "E", 1540999061, "jominey", "E", 1540999131, "jominey", "E", 1540999163, "jominey", "E", 1572480389, "sendnoodlez", "X", 1572480754, "sendnoodlez", "X", 1572481513, "sendnoodlez", "E", 1579646566, "sendnoodlez", "E", 1579713339, "jominey", "E", 1579713491, "jominey", "E", 1579713498, "jominey", "E", 1579713505, "jominey", "E" \})
      </Core:Property>
      <Core:Property property="skill:fatigue">1.0</Core:Property>
    </Core:Properties>
    <Notes:Notes>
      <Notes:Category cat="QA" catstate="Open">
        <Notes:Note ix="1166428735" state="Open" user="tonyd">
           Commands:
gather my deck - gathers all the missing cards for the deck, placing them back into the deck
shuffle my deck - shuffles the cards in the deck
deal my deck - takes a card from the deck
deal my deck to <person/> - deals a card to another player
deal my deck '<number/> - deals that number of cards
deal my deck to <person/> '<number/> - deals that number of cards to another player
deal my deck rightside-up - displays what cards are drawn when dealing
deal my deck upside-down - hides which cards are drawn when dealing
strip my deck '<criteria/> - goes through the deck, removing specified cards.
criteria when stripping a deck can be numbers or words. For example you can "strip my deck 'queen" to remove all queens, or "strip my deck '3" to remove all 3's. You can also "strip my deck 'three" to remove all threes. Specifically named cards can also be stripped from a deck.
commands for the cards:
reveal my card - shows other players what the card is
conceal my card - stops showing what the card is
scan my cards - lists the cards in suit order, including a number so players know which card is which when targetting (i.e. the card with number 4 is "my fourth card")
place my card on deck - puts the card on the top of the deck
place my card under deck - puts the card on the bottom of the deck
shuffle my card into deck - shuffles the card into the deck
note: cards from different packs can be shuffled into a deck. This allows players to create double decks, etc.
        </Notes:Note>
      </Notes:Category>
    </Notes:Notes>
  </Base:Thing>
</object>
