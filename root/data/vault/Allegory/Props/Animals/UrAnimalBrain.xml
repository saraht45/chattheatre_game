<object clone="/base/obj/thing" owner="SkotOS">
  <Base:Thing>
    <Ur:UrObject/>
    <Base:Bulk immobile="false" mass="1" density="1"/>
    <Base:Container flexible="false" transparent-container="false" public-container="false" tight="false" capacity="1" maxweight="1"/>
    <Base:Misc gender="neuter" volition="false" weapon="false" default_stance="none" combinable="false" discrete="false" by_weight="false" tight="false" scriptrunner="true">
      <Base:Edible value="false"/>
      <Base:Potable value="false"/>
      <Base:DrinkMessageFirst/>
      <Base:DrinkMessageThird/>
      <Base:Transparency value="false"/>
      <Base:Unsafe value="false"/>
      <Base:Safe value="false"/>
      <Base:ClothesExpected value="false"/>
      <Base:DieMessageFirst/>
      <Base:DieMessageThird/>
    </Base:Misc>
    <Base:Details/>
    <Base:Combat>
      <Base:Strength value="1"/>
      <Base:MaxFatigue value="1"/>
    </Base:Combat>
    <Base:Clothing>
      <Base:SingleWear value="false"/>
    </Base:Clothing>
    <Base:Crafting see_level="0" do_level="0" time="0" attention="false" held="false">
      <Base:Ingredients/>
      <Base:Tools/>
      <Base:CraftVerbs/>
    </Base:Crafting>
    <Base:InitialContents/>
    <Base:InitialProperties/>
    <Core:Properties>
      <Core:Property property="error">
         "Libraries are needed: \<Lib:NIP:lib:emoting\>"
      </Core:Property>
      <Core:Property property="export:nip-core:hooks">
         ([ "decide":\<Lib:NIP:base:hooks:decide\>, "delay":\<Lib:NIP:base:hooks:delay\>, "emoting":\<Lib:NIP:lib:emoting\>, "freemoting":\<Lib:NIP:lib:freemoting\>, "internal":\<Lib:NIP:base:hooks:internal\>, "movement":\<Lib:NIP:lib:movement\>, "resource-control":\<Lib:NIP:lib:resource-control\> ])
      </Core:Property>
      <Core:Property property="export:nip-core:inherits">
         ([ \<Lib:NIP:base:lib:hooks\>:(\{ "lib:core:find-hook", "lib:core:register-hook", "lib:core:unregister-hook", "lib:modify:hooks", "setprop-post:hook" \}), \<Lib:NIP:base:lib:signals\>:(\{ "lib:modify:signals", "setprop-post:signal", "lib:calc_sighookpath" \}), \<Lib:NIP:base:lib:stream\>:(\{ "setprop-post:sigexecptr", "setprop-post:sigstream" \}), \<Lib:NIP:base:signals:DECIDE\>:(\{ "setprop-post:decide" \}), \<Lib:NIP:lib:autostart\>:(\{ "lib:handler:start:auto" \}), \<Lib:NIP:lib:emoting\>:(\{ "lib:handler:emoting:parse", "lib:behave", "lib:handler:emoting:preparse" \}), \<Lib:NIP:lib:freemoting\>:(\{ "lib:handler_freemote" \}), \<Lib:NIP:lib:movement\>:(\{ "lib:core_movement_exit" \}), \<Lib:NIP:lib:resource-control\>:(\{ "witness-post:login%nip:resource-control", "witness:enter-from%nip:resource-control", "witness:teleport%resource-control", "lib:entering" \}), \<Lib:NIP:lib:spawn-control\>:(\{ "act:stop" \}), \<Allegory:Lib:Controls:Pets:PetControls\>:(\{ "lib:access", "lib:allow", "lib:amialone", "react-pre:take", "react:control-dob", "react:name-dob", "timer:amialone", "lib:deny", "lib:follow", "lib:stay", "lib:dress", "lib:undress", "react:feed-dob", "react:feed-iob", "lib:readyfortending", "lib:readyforharvest" \}) ])
      </Core:Property>
      <Core:Property property="export:nip-core:libraries">
         (\{ \<Lib:NIP:base:lib:signals\>, \<Lib:NIP:base:lib:hooks\>, \<Lib:NIP:base:lib:stream\>, \<Lib:NIP:lib:resource-control\>, \<Lib:NIP:core\>, \<Lib:NIP:base:signals:DELAY\>, \<Lib:NIP:base:signals:DECIDE\>, \<Lib:NIP:base:signals:INTERNAL\>, \<Lib:NIP:lib:autostart\>, \<Lib:NIP:lib:movement\>, \<Lib:NIP:lib:spawn-control\>, \<Lib:NIP:lib:emoting\>, \<Lib:NIP:lib:freemoting\>, \<Allegory:Lib:Controls:Pets:PetControls\> \})
      </Core:Property>
      <Core:Property property="export:nip-core:prop:nip:behavior:">
         ([ 4:1 ])
      </Core:Property>
      <Core:Property property="export:nip-core:prop:nip:trait:emoting:frequency">
         ([ 1:1 ])
      </Core:Property>
      <Core:Property property="export:nip-core:prop:nip:trait:freemoting:frequency">
         ([ 1:1 ])
      </Core:Property>
      <Core:Property property="export:nip-core:prop:nip:trait:hints:">
         ([ 4:1 ])
      </Core:Property>
      <Core:Property property="export:nip-core:prop:nip:trait:movement:frequency">
         ([ 1:1 ])
      </Core:Property>
      <Core:Property property="export:nip-core:prop:nip:trait:resource-control:ttl">
         ([ 1:1 ])
      </Core:Property>
      <Core:Property property="export:nip-core:prop:nip:trait:resource-control:ttl_increase">
         ([ 1:1 ])
      </Core:Property>
      <Core:Property property="export:nip-core:prop:nip:trait:spawn:area">
         ([ 4:1 ])
      </Core:Property>
      <Core:Property property="export:nip-core:sighookpath">
         (\{ "delay:DELAY-init", "delay:DELAY-exec", "resource-control:INTERNAL", "internal:INTERNAL-exec", "decide:DECIDE-init", "emoting:DECIDE", "freemoting:DECIDE", "movement:DECIDE", "decide:DECIDE-exec", "decide:DECIDE-post" \})
      </Core:Property>
      <Core:Property property="export:nip-core:signals">
         ([ 10:"DELAY", 500:"INTERNAL", 1000:"DECIDE" ])
      </Core:Property>
      <Core:Property property="export:nip-core:system:revision">
         44
      </Core:Property>
      <Core:Property property="export:nip:start">
         (\{ "handler:start:auto", "configure" \})
      </Core:Property>
      <Core:Property property="export:nip:trait:emoting:frequency">
         2
      </Core:Property>
      <Core:Property property="export:nip:trait:freemoting:frequency">
         20
      </Core:Property>
      <Core:Property property="export:nip:trait:freemoting:steal-frequency">
         10
      </Core:Property>
      <Core:Property property="export:nip:trait:movement:frequency">
         10
      </Core:Property>
      <Core:Property property="export:nip:trait:resource-control:ttl">
         1800
      </Core:Property>
      <Core:Property property="export:nip:trait:resource-control:ttl_increase">
         600
      </Core:Property>
      <Core:Property property="export:trait:commands:default">
         (\{ "access", "allow", "deny", "follow", "freemote", "stay", "dress", "undress" \})
      </Core:Property>
      <Core:Property property="loading">1</Core:Property>
      <Core:Property property="merry:act-pre:enter%footprints">
         X[M] if(!Get(\$this."base:environment", "details:" + NRefDetail(\$what) + ":exit:dest")) return TRUE;  
  
Call(\$\{Allegory:Lib:Controls:Pets:PetControls\}, "footprint", \$exit: \$what, \$animal: \$this);  
  
return TRUE;
      </Core:Property>
      <Core:Property property="merry:act:enter-into">
         X[M] if(this.combat) return TRUE;  
if(!\$actor."udat:object") return TRUE;  
if(this."tmp:starting_fight") return TRUE;  
if(!this."combat:aggressive") return TRUE;  
this."tmp:starting_fight" = TRUE;  
if(\$this."combat:state") return TRUE;  
  
ironclaw::set_prop(\$obj: \$this, \$prop: "nip:trait:movement:frequency", \$value: 0, \$timer: 25); /* Don't move around while fighting someone... */  
\$delay(3, TRUE, "e14b");  
  
this."tmp:choosing_target" = nil;  
  
\$target = ::find_target();  
  
this."tmp:starting_fight" = nil;  
  
if(!\$target \|\| \$target."base:environment" != this."base:environment") return TRUE;  
  
/* Do something when attacking someone */  
if(FindMerry(\$this, "lib", "combat_start")) \{  
    Call(\$this, "combat_start");  
\}  
  
/* Start the fight */  
/*   
combat::start_fight(\$attacker: \$target, \$target: this);  
*/  
  
combat::start_fight(\$attacker: \$this, \$target: \$target);  
  
return TRUE;
      </Core:Property>
      <Core:Property property="merry:inherit:act:start">
         \<Lib:NIP:core\>
      </Core:Property>
      <Core:Property property="merry:inherit:act:stop">
         \<Lib:NIP:lib:spawn-control\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:access">
         \<Allegory:Lib:Controls:General\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:allow">
         \<Allegory:Lib:Controls:General\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:behave">
         \<Lib:NIP:lib:emoting\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:calc_sighookpath">
         \<Lib:NIP:base:lib:signals\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:core:find-hook">
         \<Lib:NIP:base:lib:hooks\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:core:merry_add">
         \<Lib:NIP:core\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:core:merry_delete">
         \<Lib:NIP:core\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:core:register-hook">
         \<Lib:NIP:base:lib:hooks\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:core:sysupdate">
         \<Lib:NIP:core\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:core:unregister-hook">
         \<Lib:NIP:base:lib:hooks\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:core_movement_exit">
         \<Lib:NIP:lib:movement\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:decide:decide-exec">
         \<Lib:NIP:base:hooks:decide\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:decide:decide-init">
         \<Lib:NIP:base:hooks:decide\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:decide:decide-post">
         \<Lib:NIP:base:hooks:decide\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:delay:delay-exec">
         \<Lib:NIP:base:hooks:delay\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:delay:delay-init">
         \<Lib:NIP:base:hooks:delay\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:deny">
         \<Allegory:Lib:Controls:General\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:dress">
         \<Allegory:Lib:Controls:General\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:emoting:decide">
         \<Lib:NIP:lib:emoting\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:entering">
         \<Lib:NIP:lib:resource-control\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:find_nip_object">
         \<Lib:NIP:core\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:follow">
         \<Allegory:Lib:Controls:Pets:PetControls\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:freemote">
         \<Allegory:Lib:Controls:General\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:freemoting:decide">
         \<Lib:NIP:lib:freemoting\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:handler:emoting:parse">
         \<Lib:NIP:lib:emoting\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:handler:emoting:preparse">
         \<Lib:NIP:lib:emoting\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:handler:start:auto">
         \<Lib:NIP:lib:autostart\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:handler_freemote">
         \<Lib:NIP:lib:freemoting\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:heartbeat">
         \<Lib:NIP:core\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:internal:internal-exec">
         \<Lib:NIP:base:hooks:internal\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:log">
         \<Lib:NIP:core\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:modify:hooks">
         \<Lib:NIP:base:lib:hooks\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:modify:libraries">
         \<Lib:NIP:core\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:modify:signals">
         \<Lib:NIP:base:lib:signals\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:movement:decide">
         \<Lib:NIP:lib:movement\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:ncs:handler">
         \<Lib:NIP:NCS\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:readyforharvest">
         \<Allegory:Lib:Controls:Pets:PetControls\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:readyfortending">
         \<Allegory:Lib:Controls:Pets:PetControls\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:resource-control:internal">
         \<Lib:NIP:lib:resource-control\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:shutdown">
         \<Lib:NIP:core\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:stay">
         \<Allegory:Lib:Controls:Pets:PetControls\>
      </Core:Property>
      <Core:Property property="merry:inherit:lib:undress">
         \<Allegory:Lib:Controls:General\>
      </Core:Property>
      <Core:Property property="merry:inherit:react-pre:take">
         \<Allegory:Lib:Controls:General\>
      </Core:Property>
      <Core:Property property="merry:inherit:react:control-dob">
         \<Allegory:Lib:Controls:General\>
      </Core:Property>
      <Core:Property property="merry:inherit:react:feed-iob">
         \<Allegory:Lib:Controls:Pets:PetControls\>
      </Core:Property>
      <Core:Property property="merry:inherit:react:name-dob">
         \<Allegory:Lib:Controls:Pets:PetControls\>
      </Core:Property>
      <Core:Property property="merry:inherit:setprop-post:add">
         \<Lib:NIP:core\>
      </Core:Property>
      <Core:Property property="merry:inherit:setprop-post:decide">
         \<Lib:NIP:base:signals:DECIDE\>
      </Core:Property>
      <Core:Property property="merry:inherit:setprop-post:del">
         \<Lib:NIP:core\>
      </Core:Property>
      <Core:Property property="merry:inherit:setprop-post:delete">
         \<Lib:NIP:core\>
      </Core:Property>
      <Core:Property property="merry:inherit:setprop-post:error">
         \<Lib:NIP:core\>
      </Core:Property>
      <Core:Property property="merry:inherit:setprop-post:hook">
         \<Lib:NIP:base:lib:hooks\>
      </Core:Property>
      <Core:Property property="merry:inherit:setprop-post:nip">
         \<Lib:NIP:core\>
      </Core:Property>
      <Core:Property property="merry:inherit:setprop-post:nip-core">
         \<Lib:NIP:core\>
      </Core:Property>
      <Core:Property property="merry:inherit:setprop-post:sigexecptr">
         \<Lib:NIP:base:lib:stream\>
      </Core:Property>
      <Core:Property property="merry:inherit:setprop-post:signal">
         \<Lib:NIP:base:lib:signals\>
      </Core:Property>
      <Core:Property property="merry:inherit:setprop-post:sigstream">
         \<Lib:NIP:base:lib:stream\>
      </Core:Property>
      <Core:Property property="merry:inherit:setprop-post:sub">
         \<Lib:NIP:core\>
      </Core:Property>
      <Core:Property property="merry:inherit:witness-post:login%nip:resource-control">
         \<Lib:NIP:lib:resource-control\>
      </Core:Property>
      <Core:Property property="merry:inherit:witness:enter-from%nip:resource-control">
         \<Lib:NIP:lib:resource-control\>
      </Core:Property>
      <Core:Property property="merry:inherit:witness:teleport%resource-control">
         \<Lib:NIP:lib:resource-control\>
      </Core:Property>
      <Core:Property property="merry:lib:add_object_to_mapping">
         X[M] /*   
  D=Add sname/pname/adjective data to a set of mappings.   
*/   
NRef dest;   
string det, *strings, *details;   
int i, j, jsz, sz;   
   
if( \$all_details ) \{   
  details = \$ob."base:details";   
  sz = sizeof( details );   
\} else \{   
  details = (\{ NRefDetail(\$ob) \});   
  sz = 1;   
\}   
  
for( i = 0; i \< sz; i++ ) \{   
    det = details[i];   
    dest = NewNRef( \$ob, det );   
    \$destinations++;   
    \$destination[\$destinations] = dest;   
    strings = Get( \$ob, "details:"+det+":snames" );   
    jsz = sizeof( strings );   
    if( !\$snames[\$destinations] ) \{   
      \$snames[\$destinations] = ([ ]);   
      \$pnames[\$destinations] = ([ ]);   
      \$adjectives[\$destinations] = ([ ]);   
    \}   
   
    for( j = 0; j \< jsz; j++ ) \{   
      \$snames[\$destinations] += ([ strings[j] : TRUE ]);   
   
      \$pname = Get( \$ob, "details:"+det+":sname:"+strings[j] );   
      if( typeof(\$pname) == T_STRING )   
        \$pnames[\$destinations] += ([ \$pname : TRUE ]);   
    \}   
    strings = Get( \$ob, "details:"+det+":adjectives" );   
    jsz = sizeof( strings );   
    for( j = 0; j \< jsz; j++ )    
      \$adjectives[\$destinations] += ([ strings[j] : TRUE ]);   
   
\}
      </Core:Property>
      <Core:Property property="merry:lib:combat_getdamaged">
         X[M] if(\$this."combat:dead") return TRUE;   
if(Int(\$damage) == 0) return TRUE;   
  
if(\$this."status:health-max") \{  
    \$max = \$this."status:health-max";  
\} else \{  
    \$max = 40;  
\}  
  
if(\$this."effect:health:severity" \>= \$max) \{  
    \$this."combat:fightable" = 0;  
    \$this."combat:dead" = 1;   
    EmitIn(\$this."base:environment", Describe(\$this)+" dies from its wounds.");   
    ::die();   
\}  
  
return TRUE;
      </Core:Property>
      <Core:Property property="merry:lib:die">
         X[M] combat::remove_from_combat(\$fighter: \$this);  
\$delay(0.5, FALSE, "9937");
/* \$this."combat:dead" = TRUE;  
Set(\$this, "details:default:sname:corpse", TRUE);  
Set(\$this, "details:default:pname:corpses", TRUE);  
Set(\$this, "details:default:adjective:dead", TRUE);  
\$this."status:hurt" = nil;   
\$this."savedprop:status:hurt" = nil;   
\$this."status:afraid" = nil;   
\$this."savedprop:status:afraid" = nil;   
\$this."status:recently_afraid" = nil;   
\$this."savedprop:status:recently_afraid" = nil;   
\$this."status:injured" = nil;   
\$this."savedprop:status:injured" = nil;  */
 
\$this."nip:trait:movement:frequency" = 0;  

\$corpse = Spawn(\$\{Allegory:Props:Animals:UrCorpse\});

\$corpse."trait:brief" = \$this."trait:brief";
\$corpse."trait:examine" = \$this."trait:examine";
\$corpse."skinning:loot" = \$this."skinning:loot";
\$corpse."taxidermy:options" = \$this."taxidermy:options";
\$corpse."trait:skintype" = \$this."trait:skintype";
\$corpse."trait:feathertype" = \$this."trait:feathertype";
\$corpse."trait:appearance:color" = \$this."trait:appearance:color";
\$corpse."trait:appearance:build" = \$this."trait:appearance:build";
\$corpse."trait:animaltype" = \$this."trait:animaltype";
\$corpse."trait:size" = \$this."trait:size";
\$corpse."combat:dead" = TRUE;

\$inv = \$this."base:inventory";

for(\$i = 0; \$i \< sizeof(\$inv); \$i++) \{
    if(\$inv[\$i]."base:immobile") \{
        \$inv[\$i]."base:immobile" = FALSE;
        \$inv[\$i]."base:environment" = \$corpse;
        \$inv[\$i]."base:immobile" = TRUE;
    \} else \{
        \$inv[\$i]."base:environment" = \$corpse;
    \}

    /* Did not fit in corpse */
    if(!\$inv[\$i]."base:environment") Slay(\$inv[\$i]);
\}

\$snames = \$this."details:default:snames";
for(\$i = 0; \$i \< sizeof(\$snames); \$i++) \{
    Set(\$corpse, "details:default:sname:" + \$snames[\$i], TRUE);
\}

\$pnames = \$this."details:default:pnames";
for(\$i = 0; \$i \< sizeof(\$pnames); \$i++) \{
    Set(\$corpse, "details:default:pname:" + \$pnames[\$i], TRUE);
\}

\$adjectives = \$this."details:default:adjectives";
for(\$i = 0; \$i \< sizeof(\$adjectives); \$i++) \{
    Set(\$corpse, "details:default:adjective:" + \$adjectives[\$i], TRUE);
\}

/* \$delay(60*5, FALSE, "d3ee"); */  
/* \$delay(60*10, FALSE, "d943"); */
  
/* EmitIn(\$this."base:environment", Describe(\$this) + " really starts to rot."); */

\$corpse."base:environment" = \$this."base:environment";
Slay(\$this);
      </Core:Property>
      <Core:Property property="merry:lib:eat">
         X[M] \$food."base:environment" = \$this;  
  
\$delay(0.01, TRUE, "8aed");  
  
Social(\$this, "gobble", nil, nil, nil, \$food);  
  
return TRUE;
      </Core:Property>
      <Core:Property property="merry:lib:find_target">
         X[M] /* When the NPC is looking for a target */    
int i;    
    
/* In this example, we want to target PCs */    
\$options = Match(this."base:environment", "pc");    
\$preferred_options = (\{ \});    
    
/* We need to convert the NRef's from the PC list into objects */    
for(i=0; i\<sizeof(\$options); i++)    
  \$options[i] = NRefOb(\$options[i]);    
  
/* We prefer to target PCs that are already attacking us */    
for(i=0; i\<sizeof(\$options); i++) \{    
  if(\$options[i]."udat:object" \&\& \$options[i].combat \&\& \$options[i].combat["target"] == this) \$preferred_options += (\{ \$options[i] \});    
\}    
  
if(sizeof(\$preferred_options)) return \$preferred_options[random(sizeof(\$preferred_options))];    
  
/* Next prefer to target PCs that are already in combat with us */    
for(i=0; i\<sizeof(\$options); i++) \{    
  if(\$options[i]."udat:object" \&\& \$options[i].combat) \$preferred_options += (\{ \$options[i] \});    
\}   
  
if(sizeof(\$preferred_options)) return \$preferred_options[random(sizeof(\$preferred_options))];    
    
/* Next prefer to target PCs that aren't dying or dead or injured */    
for(i=0; i\<sizeof(\$options); i++) \{    
  if(\$options[i]."udat:object" \&\& !\$options[i]."combat:state") \$preferred_options += (\{ \$options[i] \});    
\}    
if(sizeof(\$preferred_options)) return \$preferred_options[random(sizeof(\$preferred_options))];    
    
return nil;
      </Core:Property>
      <Core:Property property="merry:lib:get_attacked">
         X[M] if(\$attacker."base:environment" == \$this."base:environment") \{  
    return TRUE;  
\}  
\$delay(0.1, FALSE, "8063");  
if(FindMerry(\$this, "lib", "run_away") \&\& !\$this."combat:dead") \{  
    EmitTo(\$actor, Describe(this) + " flees!");  
    Call(\$this, "run_away");  
    combat::remove_from_combat(\$fighter: \$attacker);   
    combat::remove_from_combat(\$fighter: this);    
\}  
   
return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:give_combat_damage">
         X[M] /* If the npc is not a killer, knock the pc out of combat */   
if(!\$this."combat:killer") \{   
     if((Int(NRefOb(\$target)."effect:health:severity") + \$damage) \>= (Int(\$target."status:health-max") - 10)) \{  
        \$delay(0.5, FALSE, "30de");    
        \$target."tmp:combat:UrFightingPerson:defeated" = Int(\$target."tmp:combat:UrFightingPerson:defeated")+1;    
  
        /* Figure out what sort of damage we're giving */  
  
        if(\$attack_options["damagetype"]) \{  
            \$attacktype = \$attack_options["damagetype"][0];  
            \$woundtype = \$attack_options["damagetype"][1];  
        \} else if(\$attack_options["weapon"]."weapon:damagetype") \{  
            \$attacktype = \$attack_options["weapon"]."weapon:damagetype"[random(sizeof(\$attack_options["weapon"]."weapon:damagetype"))];  
            \$woundtype = \$attacktype[1];  
            \$attacktype = \$attacktype[0];  
        \} else \{  
            \$attacktype = "strike";  
            \$woundtype = "bruise";  
        \}  
  
        if(!\$attack_options["target_detail"] \|\| NRefDetail(\$attack_options["target_detail"]) == "default") \{  
            \$details = (\{ "chest", "right-arm", "left-arm", "right-shoulder", "left-shoulder", "right-armpit", "left-armpit", "right-bicep", "left-bicep", "right-hand", "left-hand", "right-wrist", "left-wrist", "right-forearm", "left-forearm", "right-leg", "left-leg", "right-thigh", "left-thigh", "right-calf", "left-calf", "right-knee", "left-knee", "right-elbow", "left-elbow", "right-side", "left-side", "hips", "ribs", "stomach", "gut" \});  
            \$attack_options["target_detail"] = NewNRef(\$attack_options["target"], "default");  
            while(sizeof(\$details)) \{  
                \$tmp = \$details[random(sizeof(\$details))];  
                if(Get(\$attack_options["target"], "details:"+\$tmp+":snames") \&\& sizeof(Get(\$attack_options["target"], "details:"+\$tmp+":snames"))) \{  
                    \$attack_options["target_detail"] = NewNRef(\$attack_options["target"], \$tmp);  
                    \$details = (\{ \});  
                \} else \{  
                    \$details -= (\{ \$tmp \});  
                \}  
            \}  
        \}  
  
        \$target_detail = \$attack_options["target_detail"];  
  
        if(\$weapon."combat:effects") \{  
            \$complications = \$weapon."combat:effects";  
            \$weapon."combat:effects" = nil;  
        \} else \{  
            \$complications = nil;  
        \}  
  
        \$wound_info = Call(\$\{Allegory:Lib:Combat:Cards:Libraries:Wounds\}, "get_wound", \$target_detail: \$attack_options["target_detail"], \$attacktype: \$attacktype, \$wound: \$woundtype, \$complications: \$complications, \$level: \$damage, \$par: ([ ]));  
  
        /* Do something when npc defeats a pc */   
        if(FindMerry(\$this, "lib", "combat_win")) \{   
            Call(\$this, "combat_win");   
        \}   
  
        \$wound = Call(\$\{Allegory:Lib:Combat:Cards:Libraries:Wounds\}, "give_wound", \$target_detail: \$target_detail, \$wound_info: \$wound_info, \$char: \$char, \$par: ([ ]));  
  
   
        \$char.combat["target"] = nil;    
        combat::remove_from_combat(\$fighter: \$target);    
        combat::end_turn(\$char: \$char, \$no_loop_trigger: FALSE);    
        Set(\$this, "nip:trait:movement:frequency", 10);  
        return FALSE;    
    \}   
\}    
return TRUE;
      </Core:Property>
      <Core:Property property="merry:lib:point">
         X[M] /*   
  Simulation of a non-raw verb role, so as to be able to figure out one/many objects by in-game specification, such as "all my blue apples" or "george's thirteenth garment" etc.   
   
  Supported syntax =   
    [all] [[\<target\>'s\|my] [\<object\>'s [...]]] [numeric] [adjective(s)] [sname/pname] [and ...]   
   
  Supported arguments:   
    \$prime_source: defaults to nil. If set, it will be the environment in which the object(s) will be sought for.   
   
*/   
   
constant PHASE_PRE = 0;   
constant PHASE_OBJ = 1;   
   
NRef *targets, *tmp;   
int numerical, i, j, jsz, sz, all, *res;   
object source, *list;   
string det, word, rest, *tpoint, *words, *strings;   
   
if( !\$point )    
  return nil;   
   
/*   
 * Divide by the "and" keyword and resolve each   
 * individually and add to chain.   
 */   
tpoint = explode( \$point, " and " );   
if( sizeof( tpoint ) \> 1 ) \{   
  targets = (\{ \});   
  for( i = 0; i \< sizeof( tpoint ); i++ )    
    if( (tmp = ::point(\$point: tpoint[i], \$prime_source: \$prime_source)) )   
      targets += tmp;   
    else   
      return nil;   
  return targets;   
\}   
   
/*   
 * Divide possessive references.   
 */   
   
all = !!\$all;   
source = nil;   
   
if( !\$prime_source \&\& strlen(\$point)\>4 \&\& \$point[..3] == "all " ) \{   
  all = TRUE;   
  \$point = \$point[4..];   
\}   
   
while( sscanf( \$point, "%s'%s", word, rest ) == 2 ) \{   
  if( rest[..1] == "s " )   
    rest = rest[2..];   
  else   
    rest = rest[1..];   
  targets = ::point(\$point: word, \$prime_source: \$prime_source, \$all: all);   
  if( sizeof( targets ) != 1 )   
    return nil;   
  \$prime_source = NRefOb(targets[0]);   
  \$point = rest;   
\}  
  
\$destinations = -1;   
\$destination = ([ ]);   
   
if( !\$prime_source \&\& strlen(\$point)\>3 \&\& \$point[..2] == "my " ) \{   
  \$point = \$point[3..];   
  source = \$actor;   
\} else   
  source = \$prime_source;   
   
/*   
 * Find numeric targeting.   
 */   
   
words = explode( \$point, " " );   
   
word = words[0];   
sz = strlen(word);   
   
numerical = 0;   
   
if( sz \> 2 \&\& (word[sz-3..] == "1st" \|\| word[sz-3..] == "2nd" \|\| word[sz-3..] == "3rd" \|\| word[sz-2..] == "th") \&\& !common::isnan(\$value: word[..sz-3]) ) \{   
  numerical = Int(word[..sz-3]);   
  words = words[1..];    
\}   
   
\$adjectives = ([ ]);   
\$snames = ([ ]);   
\$pnames = ([ ]);   
   
if( source ) \{   
  /*   
   * Add source inventory to list, including source's details.   
   */   
  list = source."base:inventory";   
  
  sz = sizeof( list );   
  for( i = 0; i \< sz; i++ ) \{  
    ::add_object_to_mapping(\$ob: list[i], \$all_details: list[i] == NRefOb(source));  
  \}  
  
  ::add_object_to_mapping(\$ob: NRefOb(source), \$all_details: TRUE);  
\} else \{   
  /*   
   * Add actor's inventory to list.    
   */   
  list = \$actor."base:inventory";   
  sz = sizeof( list );   
  for( i = 0; i \< sz; i++ )   
    ::add_object_to_mapping(\$ob: list[i], \$all_details: FALSE);   
   
  /*   
   * Additionally, add room's inventory to list, including actor details.   
   */   
  list = \$actor."base:environment"."base:inventory";   
  sz = sizeof( list );   
  for( i = 0; i \< sz; i++ )   
    ::add_object_to_mapping(\$ob: list[i], \$all_details: list[i] == \$actor);   
   
  /*   
   * And room's details.   
   */   
  ::add_object_to_mapping(\$ob: \$actor."base:environment", \$all_details: TRUE);   
\}   
   
sz = sizeof( words );   
   
jsz = \$destinations;   
if( sz \> 1 ) \{   
  for( j = 0; j \< jsz; j++ )    
    if( \$destination[j] )   
      if( !\$adjectives[j] )    
        \$destination[j] = nil;   
      else    
        for( i = 0; i \< sz-1; i++ ) \{   
          word = words[i];   
          if( !\$adjectives[j][word] )\{   
            \$destination[j] = nil;   
            i = sz-1;   
          \}   
        \}   
\}   
   
word = words[sizeof(words)-1];   
   
res = map_indices( \$destination );   
jsz = sizeof( res );   
   
for( j = 0; j \< jsz; j++ )    
  if( !\$snames[res[j]][word] \&\& !\$pnames[res[j]][word] )\{   
    \$destination[res[j]] = nil;   
  \}   
   
if( numerical ) \{   
  \$result = map_values( \$destination );   
  if( numerical \> sizeof( \$result ))    
    return nil;   
  else    
    return (\{ \$result[numerical-1] \});   
\}   
   
return map_values( \$destination );
      </Core:Property>
      <Core:Property property="merry:lib:run_away">
         X[M] Call(\$\{Allegory:Lib:Combat:Cards:Combat\}, "breakcombat", \$char: \$this);  
Call(\$\{Allegory:Lib:Combat:Cards:Combat\}, "breakcombat", \$char: \$char);  
Social(\$this, "run", "away");  
  
::core_movement_exit();  
  
return TRUE;
      </Core:Property>
      <Core:Property property="merry:lib:take">
         X[M] if(\$this."combat:dead" == TRUE) \{  
    return TRUE;  
\}  
  
EmitTo(\$actor, Describe(\$this) + " moves out of reach.");  
EmitIn(\$actor."base:environment", Describe(\$this) + " moves out of reach of " + Describe(\$actor) + ".", \$actor);  
  
return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:take_combat_actions">
         X[M] /* When the NPC is given a turn in combat, this is the script where they decide what to do */  
int i;  
  
Set(\$this, "nip:trait:movement:frequency", 0);  
  
if(FindMerry(\$this, "lib", "combat_action_emits")) \{  
    Call(\$this, "combat_action_emits");  
\}  
  
/* Pick an action */   
if(!this.combat) return TRUE;  
\$actions = copy(this.combat["options"]);  
\$actions -= (\{ nil \});  
  
/* Do we need a new target? */  
if(!this.combat["target"])  
  this.combat["target"] = ::find_target();  
  
if(!this.combat["target"]) \{  
  /* We couldn't find a target. Remove ourselves from the fight. */  
  combat::remove_from_combat(\$fighter: this);  
  combat::end_turn(\$char: this);  
  return TRUE;  
\}  
  
if(!this.combat["target"].combat) \{  
  combat::start_fight(\$attacker: this, \$target: this.combat["target"]);  
  \$delay(0.1, TRUE, "64a5");  
\}  
  
\$turn_id = random(1000000000);  
\$params = ([ "char":this, "taking_action":TRUE, "turn_id":\$turn_id ]);  
  
  
/* Can we attack? */  
for(i=0;i\<sizeof(\$actions);i++) \{  
  if(\$actions[i][0] == "attack") \{  
    if( Call(\$actions[i][1], \$actions[i][0], \$char: \$char, \$par: nil, \$check_valid: TRUE) ) \{  
      return Call(\$actions[i][1], \$actions[i][0], \$par: \$params);  
    \}  
  \}  
\}  
  
/* Couldn't attack. Can we do another action? */  
for(i=0;i\<sizeof(\$actions);i++) \{  
  if(\$actions[i][0] == "aim" \|\| \$actions[i][0] == "guard") \{  
    if( Call(\$actions[i][1], \$actions[i][0], \$char: \$char, \$par: nil, \$check_valid: TRUE) ) \{  
  
      if(\$actions[i][0] == "aim") \{  
        if(FindMerry(\$this, "lib", "combat_action_aim_emits")) \{  
            Call(\$this, "combat_action_aim_emits");  
        \} else \{  
            EmitIn(this."base:environment", Describe(this)+" attempts to "+oneof("focus on "+Describe(this.combat["target"]), "line up an attack")+".");  
        \}  
      \} else if(\$actions[i][0] == "guard") \{  
        if(FindMerry(\$this, "lib", "combat_action_guard_emits")) \{  
            Call(\$this, "combat_action_guard_emits");  
        \} else \{  
            EmitIn(this."base:environment", Describe(this)+" shifts defensively.");  
        \}  
      \}  
  
      return Call(\$actions[i][1], \$actions[i][0], \$par: \$params);  
    \}  
  \}  
\}  
  
/* Couldn't do anything. End the turn */  
combat::end_turn(\$char: this); /* Because we return TRUE above during the delay, the script won't pass for us. So we need to tell it to pass */  
return FALSE; /* This means we didn't complete our action, so the script will need to pass for us */
      </Core:Property>
      <Core:Property property="merry:lib:take_combat_damage_dying">
         X[M] /* Script run when the NPC takes enough damage to be dying */    
\$char."tmp:combat:UrFightingPerson:won" = Int(\$char."tmp:combat:UrFightingPerson:won")+1;    
   
/* Do something when npc is defeated */   
if(FindMerry(\$this, "lib", "combat_lose")) \{   
    Call(\$this, "combat_lose");   
\}   
   
combat::remove_from_combat(\$fighter: this);    
    
return FALSE;
      </Core:Property>
      <Core:Property property="merry:react-pre:catch-what">
         X[M] return Call(\$this, "take");
      </Core:Property>
      <Core:Property property="merry:react-pre:fight-dob">
         X[M] if(\$this."combat:dead") return FALSE;  
  
if(FindMerry(\$this, "lib", "combat_start")) \{  
    Call(\$this, "combat_start");  
\} else \{  
    Social(this, "turn", nil, nil, "to", \$actor);  
\}  
  
\$target = ::find_target();  
\$target = \$actor;  
  
if(!\$target) return TRUE;  
  
combat::start_fight(\$attacker: this, \$target: \$target);  
  
return FALSE;
      </Core:Property>
      <Core:Property property="merry:react-pre:retrieve-what">
         X[M] return Call(\$this, "take");
      </Core:Property>
      <Core:Property property="merry:react-pre:snatch-dob">
         X[M] return Call(\$this, "take");
      </Core:Property>
      <Core:Property property="merry:react-pre:take">
         X[M] return Call(\$this, "take");
      </Core:Property>
      <Core:Property property="merry:react:approach">
         X[M] if(!\$this."combat:fightable") return TRUE;  
  
Call(\$this, "run_away");  
  
return FALSE;
      </Core:Property>
      <Core:Property property="merry:witness-post:enter-from">
         X[M] if(this.combat) return TRUE;  
if(!\$actor."udat:object") return TRUE;  
if(this."tmp:starting_fight") return TRUE;  
if(!this."combat:aggressive") return TRUE;  
if(\$this."combat:dead") return TRUE;  
this."tmp:starting_fight" = TRUE;  
if(\$this."combat:state") return TRUE;  
  
ironclaw::set_prop(\$obj: \$actor, \$prop: "exit:blocked", \$value: "As you rush through, "+Describe(this)+" momentarily blocks your path.", \$timer: 3);  
ironclaw::set_prop(\$obj: \$this, \$prop: "nip:trait:movement:frequency", \$value: 0, \$timer: 25); /* Don't move around while fighting someone... */  
\$delay(3, TRUE, "e14b");  
  
this."tmp:choosing_target" = nil;  
  
\$target = ::find_target();  
  
this."tmp:starting_fight" = nil;  
  
if(!\$target \|\| \$target."base:environment" != this."base:environment") return TRUE;  
  
/* Do something when attacking someone */  
if(FindMerry(\$this, "lib", "combat_start")) \{  
    Call(\$this, "combat_start");  
\}  
  
/* Start the fight */  
/*   
combat::start_fight(\$attacker: \$target, \$target: this);  
*/  
  
combat::start_fight(\$attacker: \$this, \$target: \$target);  
  
return TRUE;
      </Core:Property>
      <Core:Property property="ndp">
         " *** FINISHED ADDITION *** "
      </Core:Property>
      <Core:Property property="nip-core:hooks">
         ([ "decide":\<Lib:NIP:base:hooks:decide\>, "delay":\<Lib:NIP:base:hooks:delay\>, "emoting":\<Lib:NIP:lib:emoting\>, "freemoting":\<Lib:NIP:lib:freemoting\>, "internal":\<Lib:NIP:base:hooks:internal\>, "movement":\<Lib:NIP:lib:movement\>, "resource-control":\<Lib:NIP:lib:resource-control\> ])
      </Core:Property>
      <Core:Property property="nip-core:inherits">
         ([ \<Lib:NIP:base:lib:hooks\>:(\{ "lib:core:find-hook", "lib:core:register-hook", "lib:core:unregister-hook", "lib:modify:hooks", "setprop-post:hook" \}), \<Lib:NIP:base:lib:signals\>:(\{ "lib:modify:signals", "setprop-post:signal", "lib:calc_sighookpath" \}), \<Lib:NIP:base:lib:stream\>:(\{ "setprop-post:sigexecptr", "setprop-post:sigstream" \}), \<Lib:NIP:base:signals:DECIDE\>:(\{ "setprop-post:decide" \}), \<Lib:NIP:lib:autostart\>:(\{ "lib:handler:start:auto" \}), \<Lib:NIP:lib:emoting\>:(\{ "lib:handler:emoting:parse", "lib:behave", "lib:handler:emoting:preparse" \}), \<Lib:NIP:lib:freemoting\>:(\{ "lib:handler_freemote" \}), \<Lib:NIP:lib:movement\>:(\{ "lib:core_movement_exit" \}), \<Lib:NIP:lib:resource-control\>:(\{ "witness-post:login%nip:resource-control", "witness:enter-from%nip:resource-control", "witness:teleport%resource-control", "lib:entering" \}), \<Lib:NIP:lib:spawn-control\>:(\{ "act:stop" \}), \<Allegory:Lib:Controls:Pets:PetControls\>:(\{ "lib:access", "lib:allow", "lib:amialone", "react-pre:take", "react:control-dob", "react:name-dob", "timer:amialone", "lib:deny", "lib:follow", "lib:stay", "lib:dress", "lib:undress", "react:feed-dob", "react:feed-iob", "lib:readyfortending", "lib:readyforharvest" \}) ])
      </Core:Property>
      <Core:Property property="nip-core:libraries">
         (\{ \<Lib:NIP:base:lib:signals\>, \<Lib:NIP:base:lib:hooks\>, \<Lib:NIP:base:lib:stream\>, \<Lib:NIP:lib:resource-control\>, \<Lib:NIP:core\>, \<Lib:NIP:base:signals:DELAY\>, \<Lib:NIP:base:signals:DECIDE\>, \<Lib:NIP:base:signals:INTERNAL\>, \<Lib:NIP:lib:autostart\>, \<Lib:NIP:lib:movement\>, \<Lib:NIP:lib:spawn-control\>, \<Lib:NIP:lib:emoting\>, \<Lib:NIP:lib:freemoting\>, \<Allegory:Lib:Controls:Pets:PetControls\> \})
      </Core:Property>
      <Core:Property property="nip-core:prop:nip:behavior:">
         ([ 4:1 ])
      </Core:Property>
      <Core:Property property="nip-core:prop:nip:trait:emoting:frequency">
         ([ 1:1 ])
      </Core:Property>
      <Core:Property property="nip-core:prop:nip:trait:freemoting:frequency">
         ([ 1:1 ])
      </Core:Property>
      <Core:Property property="nip-core:prop:nip:trait:hints:">
         ([ 4:1 ])
      </Core:Property>
      <Core:Property property="nip-core:prop:nip:trait:movement:frequency">
         ([ 1:1 ])
      </Core:Property>
      <Core:Property property="nip-core:prop:nip:trait:resource-control:ttl">
         ([ 1:1 ])
      </Core:Property>
      <Core:Property property="nip-core:prop:nip:trait:resource-control:ttl_increase">
         ([ 1:1 ])
      </Core:Property>
      <Core:Property property="nip-core:prop:nip:trait:spawn:area">
         ([ 4:1 ])
      </Core:Property>
      <Core:Property property="nip-core:sighookpath">
         (\{ "delay:DELAY-init", "delay:DELAY-exec", "resource-control:INTERNAL", "internal:INTERNAL-exec", "decide:DECIDE-init", "emoting:DECIDE", "freemoting:DECIDE", "movement:DECIDE", "decide:DECIDE-exec", "decide:DECIDE-post" \})
      </Core:Property>
      <Core:Property property="nip-core:signals">
         ([ 10:"DELAY", 500:"INTERNAL", 1000:"DECIDE" ])
      </Core:Property>
      <Core:Property property="nip-core:system:revision">
         44
      </Core:Property>
      <Core:Property property="nip:start">
         (\{ "handler:start:auto", "configure" \})
      </Core:Property>
      <Core:Property property="nip:trait:emoting:frequency">
         2
      </Core:Property>
      <Core:Property property="nip:trait:freemoting:frequency">
         20
      </Core:Property>
      <Core:Property property="nip:trait:freemoting:steal-frequency">
         10
      </Core:Property>
      <Core:Property property="nip:trait:movement:frequency">
         10
      </Core:Property>
      <Core:Property property="nip:trait:resource-control:ttl">
         1800
      </Core:Property>
      <Core:Property property="nip:trait:resource-control:ttl_increase">
         600
      </Core:Property>
      <Core:Property property="npc:resource-control:live_time">
         1588996176
      </Core:Property>
      <Core:Property property="npc:status:spawndate">
         1570368899
      </Core:Property>
      <Core:Property property="npc:sys:sighookpath">
         (\{ "delay:DELAY-init", "delay:DELAY-exec", "resource-control:INTERNAL", "internal:INTERNAL-exec", "decide:DECIDE-init", "emoting:DECIDE", "freemoting:DECIDE", "movement:DECIDE", "decide:DECIDE-exec", "decide:DECIDE-post" \})
      </Core:Property>
      <Core:Property property="revisions">
         (\{ 1589377984, "jominey", "E", 1589378102, "jominey", "E", 1589378494, "jominey", "E", 1589378547, "jominey", "E", 1589378579, "jominey", "E", 1589378696, "jominey", "E", 1589379769, "jominey", "E", 1589909783, "jominey", "E", 1589911188, "jominey", "E", 1589911289, "jominey", "E", 1589911600, "jominey", "E", 1589911769, "jominey", "E", 1589911945, "jominey", "E", 1589917269, "jominey", "E", 1589917679, "jominey", "E", 1589917985, "jominey", "E", 1589920170, "jominey", "E", 1589920252, "jominey", "E", 1589931265, "jominey", "E", 1589931340, "jominey", "E", 1589931482, "jominey", "E", 1589940266, "jominey", "E", 1591150358, "jominey", "E", 1591312410, "jominey", "E", 1592016831, "jominey", "E", 1592016991, "jominey", "E", 1592017532, "jominey", "E", 1592059119, "jominey", "E", 1592059681, "jominey", "E", 1592060038, "jominey", "E", 1593786710, "jominey", "E", 1593786991, "jominey", "E", 1593790509, "jominey", "P", 1593790571, "jominey", "P", 1593790605, "jominey", "P", 1593790676, "jominey", "P", 1593899890, "jominey", "E", 1593899908, "jominey", "E", 1593899923, "jominey", "E", 1593964218, "jominey", "X", 1593964430, "jominey", "E", 1593964540, "jominey", "X", 1593964552, "jominey", "E", 1594914413, "jominey", "E", 1594914466, "jominey", "E", 1594914996, "jominey", "E", 1594915121, "jominey", "E", 1594915318, "jominey", "E", 1594922725, "jominey", "E", 1594922975, "jominey", "E", 1596939686, "jominey", "E" \})
      </Core:Property>
      <Core:Property property="sigstream">2</Core:Property>
      <Core:Property property="skill:fatigue">1.0</Core:Property>
    </Core:Properties>
    <Notes:Notes/>
  </Base:Thing>
</object>
