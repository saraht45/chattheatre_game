<object clone="/base/obj/thing" owner="diedra">
  <Base:Thing>
    <Ur:UrObject urobject="OBJ(Allegory:Setting:Rinascita:Buildings:Southwest:Warehouse2:Ur)"/>
    <Base:Bulk immobile="false" mass="1" density="1"/>
    <Base:Container flexible="false" transparent-container="false" public-container="false" tight="false" capacity="1" maxweight="1"/>
    <Base:Misc gender="neuter" volition="false" weapon="false" default_stance="none" combinable="false" discrete="false" by_weight="false" tight="false" scriptrunner="false">
      <Base:Edible value="false"/>
      <Base:Potable value="false"/>
      <Base:DrinkMessageFirst></Base:DrinkMessageFirst>
      <Base:DrinkMessageThird></Base:DrinkMessageThird>
      <Base:Transparency value="false"/>
      <Base:Unsafe value="false"/>
      <Base:Safe value="false"/>
      <Base:ClothesExpected value="false"/>
      <Base:DieMessageFirst></Base:DieMessageFirst>
      <Base:DieMessageThird></Base:DieMessageThird>
    </Base:Misc>
    <Base:Details>
      <Base:Detail id="default" prime="true" def="false" abstract="false" hidden="false" luminosity="0" targetable_in_dark="false" plural="false">
        <Base:Preposition close="true" against="true" under="true" on="true" inside="true" near="true" over="true" behind="true" before="true" beside="true"/>
        <Base:Names>
          <Base:SNames>
            <Base:SName sname="room"/>
          </Base:SNames>
          <Base:PNames>
            <Base:PName pname="rooms"/>
          </Base:PNames>
        </Base:Names>
        <Base:Adjectives/>
        <Base:Descriptions>
          <Base:Description type="brief">
             spacious room
          </Base:Description>
          <Base:Description type="examine">
             The spacious room is surrounded by $[$arr = ({ NewNRef($this, "wall-west2"), NewNRef($this, "wall-north2"), NewNRef($this, "wall-east2"), NewNRef($this, "wall-south2") }); return replace_strings(Describe($arr), "the ", "");]. <describe detail="ceiling" what="$(this)" looker="$(this)" cap="1"/> rises roughly 10 feet in height while <describe detail="floor" what="$(this)" looker="$(this)"/> covers the 20 by 20 foot space. A broad latticework window has been built into the southern wall, lending the room a view of the bay. A darkly-stained oak door is set in the west wall.
          </Base:Description>
          <Base:Description type="glance">
             The spacious room is surrounded by $[$arr = ({ NewNRef($this, "wall-west2"), NewNRef($this, "wall-north2"), NewNRef($this, "wall-east2"), NewNRef($this, "wall-south2") }); return replace_strings(Describe($arr), "the ", "");]. <describe detail="ceiling" what="$(this)" looker="$(this)" cap="1"/> rises roughly 10 feet in height while <describe detail="floor" what="$(this)" looker="$(this)"/> covers the 20 by 20 foot space. A darkly-stained oak door is set in the west wall.
          </Base:Description>
          <Base:Description type="look">
             A spacious room with four walls, a floor, and a ceiling. A door is set in the west wall and a broad window in the southern wall.
          </Base:Description>
          <Base:Description type="mapurl">
             http://www.skotos.net/IronclawGame/images/maps/<night>night/</night>docktown/central/warehouses/main up.jpg
          </Base:Description>
        </Base:Descriptions>
        <Base:Exit door="false" never_obvious="false" obvious_when_open="false" hidden_when_closed="false" separate="false" self-locking="false" deadbolt="false"/>
        <Base:Climbable/>
      </Base:Detail>
      <Base:Detail id="exit-sw" prime="false" def="false" abstract="false" hidden="false" luminosity="0" targetable_in_dark="false" plural="false">
        <Base:Preposition close="true" against="true" under="true" on="true" inside="true" near="true" over="true" behind="true" before="true" beside="true"/>
        <Base:Names>
          <Base:SNames>
            <Base:SName sname="door"/>
            <Base:SName sname="west"/>
          </Base:SNames>
          <Base:PNames>
            <Base:PName pname="doors"/>
          </Base:PNames>
        </Base:Names>
        <Base:Adjectives>
          <Base:Adjective adjective="oak"/>
          <Base:Adjective adjective="west"/>
        </Base:Adjectives>
        <Base:Descriptions>
          <Base:Description type="brief">
             darkly-stained oak door
          </Base:Description>
          <Base:Description type="examine">
             An oaken door that is rectangular and made from solid wood. It is coated with a dark stain.
          </Base:Description>
          <Base:Description type="look">
             A oak door leading to the west.
          </Base:Description>
        </Base:Descriptions>
        <Base:Exit dest="NREF(Allegory:Setting:Rinascita:Buildings:Southwest:Warehouse2:SecondFloor:StairwellSW|exit-ne)" door="true" never_obvious="false" obvious_when_open="false" hidden_when_closed="false" separate="false" self-locking="false" deadbolt="true">
          <Base:Direction dir="west"/>
        </Base:Exit>
        <Base:Climbable/>
      </Base:Detail>
      <Base:Detail id="walls" prime="false" def="false" abstract="false" hidden="false" luminosity="0" targetable_in_dark="false" plural="false">
        <Base:Preposition close="false" against="false" under="false" on="false" inside="false" near="false" over="false" behind="false" before="false" beside="false"/>
        <Base:Names>
          <Base:SNames/>
          <Base:PNames/>
        </Base:Names>
        <Base:Adjectives/>
        <Base:Descriptions>
          <Base:Description type="examine">
             The spacious room is surrounded by $[$arr = ({ NewNRef($this, "wall-west2"), NewNRef($this, "wall-north2"), NewNRef($this, "wall-east2"), NewNRef($this, "wall-south2") }); return replace_strings(Describe($arr), "the ", "");].
          </Base:Description>
          <Base:Description type="look">
             The spacious room is surrounded by $[$arr = ({ NewNRef($this, "wall-west2"), NewNRef($this, "wall-north2"), NewNRef($this, "wall-east2"), NewNRef($this, "wall-south2") }); return replace_strings(Describe($arr), "the ", "");].
          </Base:Description>
        </Base:Descriptions>
        <Base:Exit door="false" never_obvious="false" obvious_when_open="false" hidden_when_closed="false" separate="false" self-locking="false" deadbolt="false"/>
        <Base:Climbable/>
      </Base:Detail>
      <Base:Detail id="window-south" prime="false" def="false" abstract="false" hidden="false" luminosity="0" targetable_in_dark="false" plural="false">
        <Base:Preposition close="true" against="true" under="true" on="true" inside="true" near="true" over="true" behind="true" before="true" beside="true"/>
        <Base:Names>
          <Base:SNames>
            <Base:SName sname="window"/>
          </Base:SNames>
          <Base:PNames>
            <Base:PName pname="windows"/>
          </Base:PNames>
        </Base:Names>
        <Base:Adjectives>
          <Base:Adjective adjective="broad"/>
          <Base:Adjective adjective="glass"/>
          <Base:Adjective adjective="lattice"/>
          <Base:Adjective adjective="latticework"/>
          <Base:Adjective adjective="south"/>
        </Base:Adjectives>
        <Base:Descriptions>
          <Base:Description type="brief">
             broad latticework window
          </Base:Description>
          <Base:Description type="examine">
             Framed by dark-stained oak, the window in the southern wall is composed of several diamonds of glass held together by a latticework of diagonally aligned, supportive oak muntons. <br/> <describe-view view="$(Ironclaw:World:DockTown:Roads:Streets:Dock05)" type="examine"/>
          </Base:Description>
          <Base:Description type="look">
             A broad window boasting several diamonds of glass held together by a latticework of supportive oak muntons. <br/> <describe-view view="$(Ironclaw:World:DockTown:Roads:Streets:Dock05)" type="examine"/>
          </Base:Description>
        </Base:Descriptions>
        <Base:Exit door="false" never_obvious="true" obvious_when_open="false" hidden_when_closed="false" separate="false" self-locking="false" deadbolt="false"/>
        <Base:Climbable/>
      </Base:Detail>
    </Base:Details>
    <Base:Combat>
      <Base:Strength value="1"/>
      <Base:MaxFatigue value="1"/>
    </Base:Combat>
    <Base:Clothing>
      <Base:SingleWear value="false"/>
    </Base:Clothing>
    <Base:Crafting see_level="0" do_level="0" time="0" attention="false" held="false">
      <Base:Ingredients/>
      <Base:Tools/>
      <Base:CraftVerbs/>
    </Base:Crafting>
    <Base:InitialContents/>
    <Base:InitialProperties/>
    <Core:Properties>
      <Core:Property property="export:alteration:add:ceiling:ceilingpanel">
         ([ "adj-prop":(\{ "trait:color", "trait:material", "trait:type", "trait:brief" \}), "properties":(\{ (\{ "trait:color", "trait:ceiling:panel:color" \}), (\{ "trait:material", "trait:ceiling:panel:material" \}), (\{ "trait:brief", "trait:ceiling:panel:brief" \}), (\{ "trait:examine", "trait:ceiling:panel:examine" \}), (\{ "trait:type", "trait:ceiling:panel:type" \}) \}) ])
      </Core:Property>
      <Core:Property property="export:alteration:add:ceiling:roompaint">
         ([ "adj-prop":(\{ "trait:color" \}), "properties":(\{ (\{ "trait:color", "trait:ceiling:color" \}) \}) ])
      </Core:Property>
      <Core:Property property="export:alteration:add:floor:carpet">
         ([ "adj-prop":(\{ "trait:color", "trait:material", "trait:type", "trait:brief" \}), "properties":(\{ (\{ "trait:color", "trait:carpet:color" \}), (\{ "trait:material", "trait:floor:material" \}), (\{ "trait:brief", "trait:carpet:brief" \}), (\{ "trait:examine", "trait:carpet:examine" \}), (\{ "trait:type", "trait:carpet:type" \}) \}) ])
      </Core:Property>
      <Core:Property property="export:alteration:add:floor:flooring">
         ([ "adj-prop":(\{ "trait:color", "trait:material", "trait:type", "trait:brief" \}), "properties":(\{ (\{ "trait:color", "trait:floor:color" \}), (\{ "trait:material", "trait:floor:material" \}), (\{ "trait:brief", "trait:floor:brief" \}), (\{ "trait:examine", "trait:floor:examine" \}), (\{ "trait:type", "trait:floor:type" \}) \}) ])
      </Core:Property>
      <Core:Property property="export:alteration:add:floor:tiles">
         ([ "adj-prop":(\{ "trait:color", "trait:material", "trait:type", "trait:brief" \}), "properties":(\{ (\{ "trait:color", "trait:floor:color" \}), (\{ "trait:material", "trait:floor:material" \}), (\{ "trait:brief", "trait:floor:brief" \}), (\{ "trait:examine", "trait:floor:examine" \}), (\{ "trait:type", "trait:floor:type" \}) \}) ])
      </Core:Property>
      <Core:Property property="export:alteration:add:wall-east:roompaint">
         ([ "adj-prop":(\{ "trait:color" \}), "properties":(\{ (\{ "trait:color", "trait:wall-east:color" \}) \}) ])
      </Core:Property>
      <Core:Property property="export:alteration:add:wall-east:tiles">
         ([ "adj-prop":(\{ "trait:color", "trait:material", "trait:type", "trait:brief", "trait:pattern" \}), "properties":(\{ (\{ "trait:color", "trait:wall-east:color" \}), (\{ "trait:material", "trait:wall-east:material" \}), (\{ "trait:brief", "trait:wall-east:brief" \}), (\{ "trait:examine", "trait:wall-east:examine" \}), (\{ "trait:type", "trait:wall-east:type" \}), (\{ "trait:quality", "trait:wall-east:quality" \}), (\{ "trait:pattern", "trait:wall-east:pattern" \}) \}) ])
      </Core:Property>
      <Core:Property property="export:alteration:add:wall-east:wallcover">
         ([ "adj-prop":(\{ "trait:color", "trait:material", "trait:type", "trait:brief", "trait:pattern" \}), "properties":(\{ (\{ "trait:color", "trait:wall-east:color" \}), (\{ "trait:material", "trait:wall-east:material" \}), (\{ "trait:brief", "trait:wall-east:brief" \}), (\{ "trait:examine", "trait:wall-east:examine" \}), (\{ "trait:type", "trait:wall-east:type" \}), (\{ "trait:quality", "trait:wall-east:quality" \}), (\{ "trait:pattern", "trait:wall-east:pattern" \}) \}) ])
      </Core:Property>
      <Core:Property property="export:alteration:add:wall-east:wallpanel">
         ([ "adj-prop":(\{ "trait:color", "trait:material", "trait:type", "trait:brief", "trait:pattern" \}), "properties":(\{ (\{ "trait:color", "trait:wall-east:panel:color" \}), (\{ "trait:material", "trait:wall-east:panel:material" \}), (\{ "trait:brief", "trait:wall-east:panel:brief" \}), (\{ "trait:examine", "trait:wall-east:panel:examine" \}), (\{ "trait:type", "trait:wall-east:panel:type" \}), (\{ "trait:quality", "trait:wall-east:panel:quality" \}), (\{ "trait:pattern", "trait:wall-east:panel:pattern" \}) \}) ])
      </Core:Property>
      <Core:Property property="export:alteration:add:wall-north:roompaint">
         ([ "adj-prop":(\{ "trait:color" \}), "properties":(\{ (\{ "trait:color", "trait:wall-north:color" \}) \}) ])
      </Core:Property>
      <Core:Property property="export:alteration:add:wall-north:tiles">
         ([ "adj-prop":(\{ "trait:color", "trait:material", "trait:type", "trait:brief", "trait:pattern" \}), "properties":(\{ (\{ "trait:color", "trait:wall-north:color" \}), (\{ "trait:material", "trait:wall-north:material" \}), (\{ "trait:brief", "trait:wall-north:brief" \}), (\{ "trait:examine", "trait:wall-north:examine" \}), (\{ "trait:type", "trait:wall-north:type" \}), (\{ "trait:quality", "trait:wall-north:quality" \}), (\{ "trait:pattern", "trait:wall-north:pattern" \}) \}) ])
      </Core:Property>
      <Core:Property property="export:alteration:add:wall-north:wallcover">
         ([ "adj-prop":(\{ "trait:color", "trait:material", "trait:type", "trait:brief", "trait:pattern" \}), "properties":(\{ (\{ "trait:color", "trait:wall-north:color" \}), (\{ "trait:material", "trait:wall-north:material" \}), (\{ "trait:brief", "trait:wall-north:brief" \}), (\{ "trait:examine", "trait:wall-north:examine" \}), (\{ "trait:type", "trait:wall-north:type" \}), (\{ "trait:quality", "trait:wall-north:quality" \}), (\{ "trait:pattern", "trait:wall-north:pattern" \}) \}) ])
      </Core:Property>
      <Core:Property property="export:alteration:add:wall-north:wallpanel">
         ([ "adj-prop":(\{ "trait:color", "trait:material", "trait:type", "trait:brief", "trait:pattern" \}), "properties":(\{ (\{ "trait:color", "trait:wall-north:panel:color" \}), (\{ "trait:material", "trait:wall-north:panel:material" \}), (\{ "trait:brief", "trait:wall-north:panel:brief" \}), (\{ "trait:examine", "trait:wall-north:panel:examine" \}), (\{ "trait:type", "trait:wall-north:panel:type" \}), (\{ "trait:quality", "trait:wall-north:panel:quality" \}), (\{ "trait:pattern", "trait:wall-north:panel:pattern" \}) \}) ])
      </Core:Property>
      <Core:Property property="export:alteration:add:wall-south:roompaint">
         ([ "adj-prop":(\{ "trait:color" \}), "properties":(\{ (\{ "trait:color", "trait:wall-south:color" \}) \}) ])
      </Core:Property>
      <Core:Property property="export:alteration:add:wall-south:tiles">
         ([ "adj-prop":(\{ "trait:color", "trait:material", "trait:type", "trait:brief", "trait:pattern" \}), "properties":(\{ (\{ "trait:color", "trait:wall-south:color" \}), (\{ "trait:material", "trait:wall-south:material" \}), (\{ "trait:brief", "trait:wall-south:brief" \}), (\{ "trait:examine", "trait:wall-south:examine" \}), (\{ "trait:type", "trait:wall-south:type" \}), (\{ "trait:quality", "trait:wall-south:quality" \}), (\{ "trait:pattern", "trait:wall-south:pattern" \}) \}) ])
      </Core:Property>
      <Core:Property property="export:alteration:add:wall-south:wallcover">
         ([ "adj-prop":(\{ "trait:color", "trait:material", "trait:type", "trait:brief", "trait:pattern" \}), "properties":(\{ (\{ "trait:color", "trait:wall-south:color" \}), (\{ "trait:material", "trait:wall-south:material" \}), (\{ "trait:brief", "trait:wall-south:brief" \}), (\{ "trait:examine", "trait:wall-south:examine" \}), (\{ "trait:type", "trait:wall-south:type" \}), (\{ "trait:quality", "trait:wall-south:quality" \}), (\{ "trait:pattern", "trait:wall-south:pattern" \}) \}) ])
      </Core:Property>
      <Core:Property property="export:alteration:add:wall-south:wallpanel">
         ([ "adj-prop":(\{ "trait:color", "trait:material", "trait:type", "trait:brief", "trait:pattern" \}), "properties":(\{ (\{ "trait:color", "trait:wall-south:panel:color" \}), (\{ "trait:material", "trait:wall-south:panel:material" \}), (\{ "trait:brief", "trait:wall-south:panel:brief" \}), (\{ "trait:examine", "trait:wall-south:panel:examine" \}), (\{ "trait:type", "trait:wall-south:panel:type" \}), (\{ "trait:quality", "trait:wall-south:panel:quality" \}), (\{ "trait:pattern", "trait:wall-south:panel:pattern" \}) \}) ])
      </Core:Property>
      <Core:Property property="export:alteration:add:wall-west:roompaint">
         ([ "adj-prop":(\{ "trait:color" \}), "properties":(\{ (\{ "trait:color", "trait:wall-west:color" \}) \}) ])
      </Core:Property>
      <Core:Property property="export:alteration:add:wall-west:tiles">
         ([ "adj-prop":(\{ "trait:color", "trait:material", "trait:type", "trait:brief", "trait:pattern" \}), "properties":(\{ (\{ "trait:color", "trait:wall-west:color" \}), (\{ "trait:material", "trait:wall-west:material" \}), (\{ "trait:brief", "trait:wall-west:brief" \}), (\{ "trait:examine", "trait:wall-west:examine" \}), (\{ "trait:type", "trait:wall-west:type" \}), (\{ "trait:quality", "trait:wall-west:quality" \}), (\{ "trait:pattern", "trait:wall-west:pattern" \}) \}) ])
      </Core:Property>
      <Core:Property property="export:alteration:add:wall-west:wallcover">
         ([ "adj-prop":(\{ "trait:color", "trait:material", "trait:type", "trait:brief", "trait:pattern" \}), "properties":(\{ (\{ "trait:color", "trait:wall-west:color" \}), (\{ "trait:material", "trait:wall-west:material" \}), (\{ "trait:brief", "trait:wall-west:brief" \}), (\{ "trait:examine", "trait:wall-west:examine" \}), (\{ "trait:type", "trait:wall-west:type" \}), (\{ "trait:quality", "trait:wall-west:quality" \}), (\{ "trait:pattern", "trait:wall-west:pattern" \}) \}) ])
      </Core:Property>
      <Core:Property property="export:alteration:add:wall-west:wallpanel">
         ([ "adj-prop":(\{ "trait:color", "trait:material", "trait:type", "trait:brief", "trait:pattern" \}), "properties":(\{ (\{ "trait:color", "trait:wall-west:panel:color" \}), (\{ "trait:material", "trait:wall-west:panel:material" \}), (\{ "trait:brief", "trait:wall-west:panel:brief" \}), (\{ "trait:examine", "trait:wall-west:panel:examine" \}), (\{ "trait:type", "trait:wall-west:panel:type" \}), (\{ "trait:quality", "trait:wall-west:panel:quality" \}), (\{ "trait:pattern", "trait:wall-west:panel:pattern" \}) \}) ])
      </Core:Property>
      <Core:Property property="export:alteration:add:window1:shutters">
         ([ "adj-prop":(\{ "trait:color", "trait:material", "trait:type", "trait:brief" \}), "properties":(\{ (\{ "trait:color", "trait:shutters1:color" \}), (\{ "trait:material", "trait:shutters1:material" \}), (\{ "trait:brief", "trait:shutters1:brief" \}), (\{ "trait:examine", "trait:shutters1:examine" \}), (\{ "trait:type", "trait:shutters1:type" \}) \}) ])
      </Core:Property>
      <Core:Property property="export:alteration:add:window1:window">
         ([ "adj-prop":(\{ "trait:color", "trait:material", "trait:type", "trait:brief" \}), "properties":(\{ (\{ "trait:color", "trait:window1:color" \}), (\{ "trait:material", "trait:window1:material" \}), (\{ "trait:brief", "trait:window1:brief" \}), (\{ "trait:examine", "trait:window1:examine" \}), (\{ "trait:type", "trait:window1:type" \}) \}) ])
      </Core:Property>
      <Core:Property property="export:alteration:add:window2:shutters">
         ([ "adj-prop":(\{ "trait:color", "trait:material", "trait:type", "trait:brief" \}), "properties":(\{ (\{ "trait:color", "trait:shutters2:color" \}), (\{ "trait:material", "trait:shutters2:material" \}), (\{ "trait:brief", "trait:shutters2:brief" \}), (\{ "trait:examine", "trait:shutters2:examine" \}), (\{ "trait:type", "trait:shutters2:type" \}) \}) ])
      </Core:Property>
      <Core:Property property="export:alteration:add:window2:window">
         ([ "adj-prop":(\{ "trait:color", "trait:material", "trait:type", "trait:brief" \}), "properties":(\{ (\{ "trait:color", "trait:window2:color" \}), (\{ "trait:material", "trait:window2:material" \}), (\{ "trait:brief", "trait:window2:brief" \}), (\{ "trait:examine", "trait:window2:examine" \}), (\{ "trait:type", "trait:window2:type" \}) \}) ])
      </Core:Property>
      <Core:Property property="export:guild:virtual">
         "Warehouse:South"
      </Core:Property>
      <Core:Property property="export:trait:ceiling:brief">
         "joists"
      </Core:Property>
      <Core:Property property="export:trait:ceiling:examine">
         "Thick wooden beams cross the ceiling 10 feet overhead."
      </Core:Property>
      <Core:Property property="export:trait:ceiling:material">
         "oak"
      </Core:Property>
      <Core:Property property="export:trait:ceiling:type">
         "exposed"
      </Core:Property>
      <Core:Property property="export:trait:floor:brief">
         "boards"
      </Core:Property>
      <Core:Property property="export:trait:floor:color">
         "warped"
      </Core:Property>
      <Core:Property property="export:trait:floor:examine">
         "The floor is made from smooth oak planks, of various widths. The planks are not entirely evenly laid, and some have warped slightly, so that the floor is a bit uneven."
      </Core:Property>
      <Core:Property property="export:trait:floor:material">
         "oak"
      </Core:Property>
      <Core:Property property="export:trait:floor:type">
         "wood"
      </Core:Property>
      <Core:Property property="export:trait:quality">
         1
      </Core:Property>
      <Core:Property property="export:trait:wall-east:brief">
         "plaster"
      </Core:Property>
      <Core:Property property="export:trait:wall-east:color">
         "white"
      </Core:Property>
      <Core:Property property="export:trait:wall-east:examine">
         "A smoothly plastered surface finished with a lime wash."
      </Core:Property>
      <Core:Property property="export:trait:wall-east:type">
         "fresco"
      </Core:Property>
      <Core:Property property="export:trait:wall-north:brief">
         "plaster"
      </Core:Property>
      <Core:Property property="export:trait:wall-north:color">
         "white"
      </Core:Property>
      <Core:Property property="export:trait:wall-north:examine">
         "A smoothly plastered surface finished with a lime wash."
      </Core:Property>
      <Core:Property property="export:trait:wall-north:type">
         "fresco"
      </Core:Property>
      <Core:Property property="export:trait:wall-south:brief">
         "plaster"
      </Core:Property>
      <Core:Property property="export:trait:wall-south:color">
         "white"
      </Core:Property>
      <Core:Property property="export:trait:wall-south:examine">
         "A smoothly plastered surface finished with a lime wash."
      </Core:Property>
      <Core:Property property="export:trait:wall-south:type">
         "fresco"
      </Core:Property>
      <Core:Property property="export:trait:wall-west:brief">
         "plaster"
      </Core:Property>
      <Core:Property property="export:trait:wall-west:color">
         "white"
      </Core:Property>
      <Core:Property property="export:trait:wall-west:examine">
         "A smoothly plastered surface finished with a lime wash."
      </Core:Property>
      <Core:Property property="export:trait:wall-west:type">
         "fresco"
      </Core:Property>
      <Core:Property property="export:underconstruction">
         1
      </Core:Property>
      <Core:Property property="merry:lib:actionlog">
         X[M] /* 
** variables \$actor and \$action will be passed to this function 
*/ 
 
object actor; 
object *inventory; 
string furdescription, action; 
int guard_on_duty, i; 
 
actor = \$actor; 
action = \$action; 
furdescription = Describe(NewNRef(\$actor, "fur")); 
 
inventory = \$this."base:inventory"; 
guard_on_duty = 0; 
for(i = 0; i \< sizeof(inventory) \&\& guard_on_duty == 0; i++) \{ 
    \$snames = Get(inventory[i], "details:default:snames"); 
    \$isdead = Int(Get(inventory[i], "death:dead")); 
    \$isalive = Int(Get(inventory[i], "base:volition")); 
    if(member("guard", \$snames) \&\& \$isalive \&\& !\$isdead) \{ 
        guard_on_duty = 1; 
    \} 
\} 
 
\$entry = (\{ (\{ time(), actor, action, furdescription, guard_on_duty \}) \}); 
 
\$log = (\{ \}); 
if(\$this.log) \{ 
    \$log = \$this.log; 
\} 
 
\$log += \$entry; 
 
\$this.log = \$log; 
 
return TRUE;
      </Core:Property>
      <Core:Property property="merry:lib:add">
         X[M] int counter; 
/*EmitTo(\$actor, "Args = " + dump_value(args));*/ 
 
/* We should have already checked that we have two valid objects that can be added */ 
/* Make sure that the react-pre:add-iob is there, it does the checking */ 
 
/* Check again anyway */ 
if(!\$addition) return TRUE; 
if(!Call(\$\{Ironclaw:Lib:Crafting:Lib\}, "valid-check", \$addition: \$addition, \$object: \$target)) 
\{ return FALSE; \} 
 
\$addition = NRefOb(\$addition[0]); 
 
/* Check if we are allowed to add the addition to the object */ 
if(!(\$addlist = Get(NRefOb(\$target[0]), "alteration:add:" + NRefDetail(\$target[0]) + ":" + Str(\$addition."trait:objecttype")))) \{ 
  EmitTo(\$actor, "You can't combine these objects"); 
  return FALSE; 
\} 
 
/* We can combine the objects */ 
 
/* Check that this modification hasn't already been made */ 
if(\$addlist["stopvalue"]) \{ 
  /* We have a stopvalue. Check if we are allowed to continue */ 
  /* If this property exists in the object, then we need to stop, unless it matches the value */ 
  if(Get(NRefOb(\$target[0]), \$addlist["stopvalue"][0])) \{ 
    /* if stopvalue doesn't match the property, then exit with message*/ 
    if((sizeof(\$addlist["stopvalue"]) \> 1) \&\& (Get(NRefOb(\$target[0]), \$addlist["stopvalue"][0]) != \$addlist["stopvalue"][1])) \{ 
      /* Stopvalue doesn't match. Output error message */ 
      if(sizeof(\$addlist["stopvalue"]) \> 2) \{ 
        EmitTo(\$actor, \$addlist["stopvalue"][2]); 
      \} else \{ 
        EmitTo(\$actor, Describe(\$target[0], nil, \$actor) + " already has a modification of that type."); 
      \} 
      return FALSE; 
    \} 
  \} 
\} 
 
/* Check if the actor is holding the necessary consumables */ 
if(\$addition.requiredconsumables) \{ 
    \$tmp = \$addition.requiredconsumables[0]; 
    \$consumables = (\{ \}); 
    \$inventory = \$actor."base:inventory"; 
    for(\$i = 0; sizeof(\$consumables) \< sizeof(\$tmp) \&\& \$i \< sizeof(\$tmp); \$i++) \{ 
        for(\$j = 0; \$j \< sizeof(\$inventory); \$j++) \{ 
            if(\$inventory[\$j]."trait:objecttype" == \$tmp[\$i]) \{ 
                if(!member(\$inventory[\$j], \$consumables)) \{ 
                    \$consumables += (\{ \$inventory[\$j] \}); 
                \} 
            \} 
            if(sizeof(\$consumables) == sizeof(\$tmp)) break; 
        \} 
        if(sizeof(\$consumables) == sizeof(\$tmp)) break; 
    \} 
 
    if(sizeof(\$consumables) != sizeof(\$tmp)) \{ 
        EmitTo(\$actor, replace_strings(Str(\$addition.requiredconsumables[1]), "THIS", Describe(\$addition, nil, \$actor), "TARGET", Describe(\$target[0]))); 
        return FALSE; 
    \} else \{ 
        for(\$i = 0; sizeof(\$consumables) \&\& \$i \< sizeof(\$consumables); \$i++) \{ 
            Slay(\$consumables[\$i]); 
        \} 
    \} 
\} 
 
 
/* Check if the actor is carrying any necessary tools */ 
if(\$tmp = \$addlist["requiredtools"]) \{ 
  /*We require tools*/ 
  for(counter=1; counter\<sizeof(\$tmp); counter++) 
  \{ 
    /*We need a tool*/ 
    \$found = nil; 
    for(\$i = 0; (\$i \< sizeof(\$tmp[counter]))\&\&(!\$found); \$i++) 
    \{ 
      /*We need a tool of type \$tmp[counter][\$i] */ 
      for(\$j = 0; (\$j \< sizeof(\$actor."base:inventory"))\&\&(!\$found); \$j++) 
      \{ 
        if(\$actor."base:inventory"[\$j]."trait:objecttype" == \$tmp[counter][\$i]) 
        \{ 
          /*We found the tool!*/ 
          \$found = 1; 
        \} 
      \} 
 
      /* We didn't find the tool in our inventory. Is the player "using" the tool? */ 
      if(!\$found \&\& \$using) 
      \{ 
        for(\$j=0; (\$j \< sizeof(\$using))\&\&(!\$found); \$j++) 
        \{ 
          if(NRefOb(\$using[\$j])."trait:objecttype" == \$tmp[counter][\$i]) 
          \{ 
            /*We found the tool!*/ 
            /* make sure someone else isn't holding it */ 
            if(NRefOb(\$using[\$j])."base:environment"."base:volition") 
            \{ 
              EmitTo(\$actor, "You can't use a tool that's being held by someone else."); 
              return FALSE; 
            \} else \{ 
              \$found = 1; 
            \} 
          \} 
        \} 
      \} 
    \} 
    /* If we are missing a tool we need */ 
    if(!\$found) 
    \{ 
      EmitTo(\$actor, "You can't combine "+Describe(\$target[0], nil, \$actor)+" and "+Describe(\$addition, nil, \$actor)+" without "+\$tmp[0]+"."); 
      return FALSE; 
    \} 
  \} 
\} 
 
 
/* Check if these two combined creates a new object */ 
/* set whichever is the updated object to be \$object */ 
if(\$addlist["newobject"]) 
\{ 
  \$target = NRefOb(\$target[0]); 
  \$object = Spawn(\$addlist["newobject"]); 
  \$object."base:environment" = \$target."base:environment"; 
\} else \{ 
  \$object = NRefOb(\$target[0]); 
 
  /* If this is going to the existing object */ 
  /* Check if we already have this object type added 
  (i.e. adding lace to a shirt that already has lace) */ 
  /* what if this detail doesn't exist in the target? */ 
  if(sizeof(Get(\$object, "details:" + NRefDetail(\$target[0]) + ":snames:local")) \&\& sizeof(Get(\$object, "details:" + NRefDetail(\$target[0]) + ":snames:local")) \> 0) 
  \{ 
    /* The object already has snames for this detail, so we assume it has already been added previously */ 
    EmitTo(\$actor, "You cannot combine these, " + Describe(\$object, nil, \$actor) + " already has " + Describe(NewNRef(\$object, NRefDetail(\$target[0])), \$actor, nil, STYLE_NONPOSS) + "."); 
    return FALSE; 
  \} 
 
\} 
 
/* Check which new details need to be added to the new object */ 
  /* add detail snames/pnames and adjectives */ 
if(\$addlist["names"]) 
\{ 
  for(\$i = 0; \$i \< sizeof(\$addlist["names"]); \$i++) 
  \{ 
    if(sizeof(\$addlist["names"][\$i]) == 2) 
    \{ 
      Set(\$object, "details:" + NRefDetail(\$target[0]) + ":" + \$addlist["names"][\$i][0] + ":" + \$addlist["names"][\$i][1], 1); 
    \} else if(sizeof(\$addlist["names"][\$i]) \> 2) 
    \{ 
      for(\$j = 1; \$j \< sizeof(\$addlist["names"][\$i]); \$j++) 
      \{ 
 
        Set(\$object, "details:" + NRefDetail(\$target[0]) + ":" + \$addlist["names"][\$i][0] + ":" + \$addlist["names"][\$i][\$j], 1); 
      \} 
    \} 
  \} 
\} 
 
/* Adjectives to be removed from the detail. E.g. removing the current colour of an object when adding a new colour */ 
/* This should be in the object as a setprop-post trigger */ 
 
/* Check which new adjectives need to be added to the object */ 
/* This should probably also be set as a setprop post. But it's useful, so I've got both options */ 
/* Adjectives for the detail, copied from a property */ 
if(\$addlist["adj-prop"]) 
\{ 
  for(\$i=0;\$i\<sizeof(\$addlist["adj-prop"]);\$i++) 
  \{ 
    if(Get(\$addition, \$addlist["adj-prop"][\$i])) 
    \{ 
      \$tempstr = Str(UnSAM(ParseXML(dump_value(Get(\$addition, \$addlist["adj-prop"][\$i]))))); 
      Set(\$object, "details:" + NRefDetail(\$target[0]) + ":adjective:" + \$tempstr, 1); 
    \} 
  \} 
\} 
 
/* Adjectives for the default, copied from a property */ 
if(\$addlist["adj-prop-default"]) 
\{ 
  for(\$i=0;\$i\<sizeof(\$addlist["adj-prop-default"]);\$i++) 
  \{ 
    Set(\$object, "details:" + NRefDetail(\$target[0]) + ":adjective:" + Get(\$addition, \$addlist["adj-prop-default"][\$i]), 1); 
  \} 
\} 
 
/* Adjectives for the default, copied from a list */ 
if(\$addlist["adj-list-default"]) 
\{ 
  for(\$i=0;\$i\<sizeof(\$addlist["adj-list-default"]);\$i++) 
  \{ 
    Set(\$object, "details:" + NRefDetail(\$target[0]) + ":adjective:" + \$addlist["adj-list-default"][\$i], 1); 
  \} 
\} 
 
/* Check which properties should be copied to the new object */ 
if(\$addlist["properties"]) 
\{ 
  for(\$i=0;\$i\<sizeof(\$addlist["properties"]);\$i++) 
  \{ 
    if((sizeof(\$addlist["properties"][\$i]) == 2) \&\& Get(\$addition, \$addlist["properties"][\$i][0])) 
    \{ 
      Set(\$object, \$addlist["properties"][\$i][1], Str(UnSAM(Get(\$addition, \$addlist["properties"][\$i][0])))); 
    \} else \{ 
      Set(\$object, \$addlist["properties"][\$i][1], ""); 
    \} 
  \} 
\} 
 
/* Check which properties should be copied to the new object */ 
if(\$addlist["properties-this"]) 
\{ 
  for(\$i=0;\$i\<sizeof(\$addlist["properties-this"]);\$i++) 
  \{ 
    if((sizeof(\$addlist["properties-this"][\$i]) == 2) \&\& Get(\$addition, \$addlist["properties-this"][\$i][0])) 
    \{ 
      Set(\$object, \$addlist["properties-this"][\$i][1], UnSAM(Get(\$addition, \$addlist["properties-this"][\$i][0]))); 
    \} 
  \} 
\} 
 
/* Check which properties should be copied to the new object */ 
if(\$addlist["properties-list"]) 
\{ 
  for(\$i=0;\$i\<sizeof(\$addlist["properties-list"]);\$i++) 
  \{ 
    if(sizeof(\$addlist["properties-list"][\$i]) == 2) 
    \{ 
      Set(\$object, \$addlist["properties-list"][\$i][0], Str(\$addlist["properties-list"][\$i][1])); 
    \} 
  \} 
\} 
 
/* Check if we should make a skill roll, to see if the quality changes */ 
if(\$addlist["skill"]) 
\{ 
  \$result = Call(\$\{IronClaw:Lib:UrPeople:System\}, "roll", \$dicearray: (\{ \$actor."trait:mind", Get(\$actor, "skill:alteration:"+\$addlist["skill"]), Get(\$actor, "career:alteration:"+\$addlist["skill"]) \}) ); 
  if(!\$addition."trait:quality") \$addition."trait:quality" = 4; 
  if(!\$target."trait:quality") \$target."trait:quality" = 4; 
  if(\$addition."trait:quality" \> \$target."trait:quality") 
  \{ 
    \$max = \$addition."trait:quality"; 
    \$min = \$target."trait:quality"; 
  \} else \{ 
    \$max = \$target."trait:quality"; 
    \$min = \$addition."trait:quality"; 
  \} 
  if(\$result \> \$max) \{ 
    \$object."trait:quality" = \$max+1; 
  \} else if(\$result \< \$min) \{ 
    \$object."trait:quality" = \$min-1; 
  \} else \{ 
    \$object."trait:quality" = \$result; 
  \} 
\} 
 
/* Slay the original object(s) */ 
if(!\$addlist["noslay"]) 
\{ 
  Slay(\$addition); 
  if(\$addlist["newobject"]) 
  \{ 
    Slay(\$target); 
  \} 
\} 
 
::actionlog(\$actor: \$actor, \$action: "add"); 
 
return TRUE;
      </Core:Property>
      <Core:Property property="merry:lib:create">
         X[M] /*Check if we have a target to alter the object to*/      
string * blocklist;      
int counter;      
string input_words;      
mapping changemap;      
mapping changemap2;      
object new_object;      
string * valid_options;      
string tmp_string;      
      
blocklist = (\{ "input-list", "input-list-actor", "requiredtools", "description", "newobject", "newobject-properties", "noslay", "properties", "stopvalue", "skill", "fixed", "noskillroll", "cost" \});      
      
/* check we were only given one direct object */      
if(!\$target \|\| sizeof(\$target) \> 1) \{      
  EmitTo(\$actor, "You can only alter one object at a time");      
  return FALSE;      
\}      
      
if(!\$words) \{      
  if(\$words_string) \{      
    input_words = \$words_string;      
    sscanf(input_words, "\\"%s\\"", input_words);      
  \} else \{      
    input_words = "default";      
  \}      
\} else \{      
  /* We have a target to alter the object to */      
  input_words = implode(\$words, " ");      
\}      
      
/* Remove any "a" "the" "an" etc. from the targetwords */      
sscanf(input_words, "a %s", input_words);      
sscanf(input_words, "an %s", input_words);      
sscanf(input_words, "the %s", input_words);      
      
/* Replace any apostrophes. Players are too erratic in their use */      
input_words = replace_strings(input_words, "'", "");      
      
/* Check that input_words isn't included in the blocklist */      
for(counter = 0; counter \< sizeof(blocklist); counter++)      
\{      
  if(input_words == blocklist[counter])      
  \{      
    EmitTo(\$actor, "Invalid input.");      
    return FALSE;      
  \}      
\}      
      
/* Check what modification is being made */      
/* E.g. A symbol being sewn onto a shirt, or iron being forged into something new */      
if(!\$modification) \{      
  EmitTo(\$actor, "Unknown modification.");      
  return FALSE;      
\}      
      
/* verify this is a valid modification */      
if(!(changemap = Get(NRefOb(\$target[0]), "alteration:create:" + NRefDetail(\$target[0]) + ":" + \$modification))) \{      
  EmitTo(\$actor, "You can't " + \$modification + " " + Describe(\$target[0], nil, \$actor) + ".");      
  return FALSE;      
\}      
      
/* Check that we are holding the object we are modifying */      
  /* Unless we are allowed to modify without holding */      
if(!changemap["fixed"])      
\{      
  if(NRefOb(\$target[0])."base:environment" != \$actor)      
  \{      
    EmitTo(\$actor, "You can't " + \$modification + " " + Describe(\$target[0], nil, \$actor) + " if you are not holding it.");      
    return FALSE;      
  \}      
\}      
      
/* Check if the actor is carrying any necessary tools */      
if(\$tmp = changemap["requiredtools"])      
\{      
  /*We require tools*/      
  for(counter=1; counter\<sizeof(\$tmp); counter++)      
  \{      
    /*We need a tool*/      
    \$found = nil;      
    for(\$i = 0; (\$i \< sizeof(\$tmp[counter]))\&\&(!\$found); \$i++)      
    \{      
      /*We need a tool of type \$tmp[counter][\$i] */      
      for(\$j = 0; (\$j \< sizeof(\$actor."base:inventory"))\&\&(!\$found); \$j++)      
      \{      
        if(\$actor."base:inventory"[\$j]."trait:objecttype" == \$tmp[counter][\$i])      
        \{      
          /*We found the tool!*/      
          \$found = 1;      
        \}      
      \}      
      /* We didn't find the tool in our inventory. Is the player "using" the tool? */      
      if(!\$found \&\& \$using)      
      \{      
        for(\$j=0; (\$j \< sizeof(\$using))\&\&(!\$found); \$j++)      
        \{      
          if(NRefOb(\$using[\$j])."trait:objecttype" == \$tmp[counter][\$i])      
          \{      
            /*We found the tool!*/      
            /* make sure someone else isn't holding it */      
            if(NRefOb(\$using[\$j])."base:environment"."base:volition")      
            \{      
              EmitTo(\$actor, "You can't use a tool that's being held by someone else.");      
              return FALSE;      
            \} else \{      
              \$found = 1;      
            \}      
          \}      
        \}      
      \}      
    \}      
    /* If we are missing a tool we need */      
    if(!\$found)      
    \{      
      EmitTo(\$actor, "You can't "+\$modification+" "+Describe(\$target[0], nil, \$actor)+" without "+\$tmp[0]+".");      
      return FALSE;      
    \}      
  \}      
\}      
      
/* Check that the character isn't wearing the object */      
if(NRefOb(\$target[0])."base:clothing:worn")      
\{      
  EmitTo(\$actor, "You can't "+\$modification+" "+Describe(\$target[0], nil, \$actor)+" while you are wearing it.");      
  return FALSE;      
\}      
      
/* Check if we were passed the input, and if so, if it's valid */      
/* Get details for the modification */      
if(!(changemap2 = changemap[input_words]))      
\{      
  /* if property set, check in the actor for valid input */      
  if(changemap["input-list-actor"])      
  \{      
    for(counter = 0; counter \< sizeof(changemap["input-list-actor"]); counter++)      
    \{      
      if(Get(\$actor, changemap["input-list-actor"][counter]) \&\& (changemap2 = Get(\$actor, changemap["input-list-actor"][counter])[input_words])) break;      
    \}      
  \}      
  /* if not found, and property set, search other places for valid input */      
  if(!changemap2 \&\& changemap["input-list"])      
  \{      
    for(counter = 0; counter \< sizeof(changemap["input-list"]); counter++)      
    \{      
      /* Check if the object exists, and if we can retrieve the property */      
      if(changemap["input-list"][counter][0] \&\& Get(changemap["input-list"][counter][0], changemap["input-list"][counter][1]) \&\& (changemap2 = Get(changemap["input-list"][counter][0], changemap["input-list"][counter][1])[input_words])) break;      
    \}      
  \}      
      
  /* If we don't have valid input to modify the object */      
  /* Output valid options, then exit */      
  if(!changemap2)      
  \{      
    /* Check if we are allowed to continue, or if there is a stopvalue */      
    if(changemap["stopvalue"]) \{      
      /* We have a stopvalue. Check if we are allowed to continue */      
      /* If this property exists in the object, then we need to stop, unless it matches the value */      
      if(Get(NRefOb(\$target[0]), changemap["stopvalue"][0])) \{      
        /* if stopvalue doesn't match the property, then we have no tailoring options*/      
        if((sizeof(changemap["stopvalue"]) \> 1) \&\& (Get(NRefOb(\$target[0]), changemap["stopvalue"][0]) != changemap["stopvalue"][1])) \{      
          /* Stopvalue doesn't match. Output error message */      
          if(sizeof(changemap["stopvalue"]) \> 2) \{      
            EmitTo(\$actor, changemap["stopvalue"][2]);      
          \} else \{      
            EmitTo(\$actor, Describe(\$target[0], nil, \$actor) + " already has a modification of that type.");      
          \}      
          return FALSE;      
        \}      
      \}      
    \}      
      
    /* Output valid options */      
    valid_options = map_indices(changemap);      
    if(changemap["input-list-actor"])      
    \{      
      for(counter = 0; counter \< sizeof(changemap["input-list-actor"]); counter++)      
      \{      
        if(Get(\$actor, changemap["input-list-actor"][counter]) \&\& map_indices(Get(\$actor, changemap["input-list-actor"][counter])))      
        \{      
          valid_options += map_indices(Get(\$actor, changemap["input-list-actor"][counter]));      
        \}      
      \}      
    \}      
    if(changemap["input-list"])      
    \{      
      for(counter = 0; counter \< sizeof(changemap["input-list"]); counter++)      
      \{      
        if(Get(changemap["input-list"][counter][0], changemap["input-list"][counter][1]) \&\& map_indices(Get(changemap["input-list"][counter][0], changemap["input-list"][counter][1])))      
        \{      
          valid_options += map_indices(Get(changemap["input-list"][counter][0], changemap["input-list"][counter][1]));      
        \}      
      \}      
    \}      
      
    /* Remove results that aren't options */      
    valid_options -= blocklist;      
      
    /* Put options in alphabetical order */      
    valid_options = map_indices(arr_to_set(valid_options));      
      
    tmp_string = "Valid options are: ";      
    for(counter = 0; counter \< sizeof(valid_options); counter++)      
    \{      
      tmp_string += "\\"" + valid_options[counter] + "\\" ";      
    \}      
    EmitTo(\$actor, "That is not valid input to " + \$modification + " " + Describe(\$target[0], nil, \$actor));      
    EmitTo(\$actor, tmp_string);      
    return FALSE;      
  \}      
\}      
      
/* We have valid input for this modification */      
      
/* Check that this modification hasn't already been made */      
if(changemap["stopvalue"]) \{      
  /* We have a stopvalue. Check if we are allowed to continue */      
  /* If this property exists in the object, then we need to stop, unless it matches the value */      
  if(Get(NRefOb(\$target[0]), changemap["stopvalue"][0])) \{      
    /* if stopvalue doesn't match the property, then exit with message*/      
    if((sizeof(changemap["stopvalue"]) \> 1) \&\& (Get(NRefOb(\$target[0]), changemap["stopvalue"][0]) != changemap["stopvalue"][1])) \{      
      /* Stopvalue doesn't match. Output error message */      
      if(sizeof(changemap["stopvalue"]) \> 2) \{      
        EmitTo(\$actor, changemap["stopvalue"][2]);      
      \} else \{      
        EmitTo(\$actor, Describe(\$target[0], nil, \$actor) + " already has a modification of that type.");      
      \}      
      return FALSE;      
    \}      
  \}      
\}      
      
/* Check if the actor is carrying any necessary tools */      
if(\$tmp = changemap2["requiredtools"])      
\{      
  /*We require tools*/      
  for(counter=1; counter\<sizeof(\$tmp); counter++)      
  \{      
    /*We need a tool*/      
    \$found = nil;      
    for(\$i = 0; (\$i \< sizeof(\$tmp[counter]))\&\&(!\$found); \$i++)      
    \{      
      /*We need a tool of type \$tmp[counter][\$i] */      
      for(\$j = 0; (\$j \< sizeof(\$actor."base:inventory"))\&\&(!\$found); \$j++)      
      \{      
        if(\$actor."base:inventory"[\$j]."trait:objecttype" == \$tmp[counter][\$i])      
        \{      
          /*We found the tool!*/      
          \$found = 1;      
        \}      
      \}      
      /* We didn't find the tool in our inventory. Is the player "using" the tool? */      
      if(!\$found \&\& \$using)      
      \{      
        for(\$j=0; (\$j \< sizeof(\$using))\&\&(!\$found); \$j++)      
        \{      
          if(NRefOb(\$using[\$j])."trait:objecttype" == \$tmp[counter][\$i])      
          \{      
            /*We found the tool!*/      
            /* make sure someone else isn't holding it */      
            if(NRefOb(\$using[\$j])."base:environment"."base:volition")      
            \{      
              EmitTo(\$actor, "You can't use a tool that's being held by someone else.");      
              return FALSE;      
            \} else \{      
              \$found = 1;      
            \}      
          \}      
        \}      
      \}      
    \}      
    /* If we are missing a tool we need */      
    if(!\$found)      
    \{      
      EmitTo(\$actor, "You can't "+\$modification+" "+Describe(\$target[0], nil, \$actor)+" without "+\$tmp[0]+".");      
      return FALSE;      
    \}      
  \}      
\}      
      
/* -------------------------------------------------------------------------*/      
/* -------------------------------------------------------------------------*/      
/* -------------------------------------------------------------------------*/      
      
/* Check if we should decrease the quantity of our original object */      
if(changemap2["cost"]) \{      
  \$cost = changemap2["cost"][0];      
\} else if(changemap["cost"]) \{      
  \$cost = changemap["cost"][0];      
\}      
      
if(\$cost == 0) \$cost = nil;      
      
if(\$cost)      
\{      
  if(NRefOb(\$target[0])."trait:quantity" \&\& NRefOb(\$target[0])."trait:quantity" \> \$cost)      
  \{      
    NRefOb(\$target[0])."trait:quantity" -= \$cost;      
    \$cost = nil;      
  \}      
\}      
      
      
if(\$cost)      
\{      
  if(changemap2["cost"] \&\& (sizeof(changemap2["cost"]) \> 1)) \{      
    \$message = changemap2["cost"][1];      
  \} else if(changemap["cost"] \&\& (sizeof(changemap["cost"]) \> 1)) \{      
    \$message = changemap["cost"][1];      
  \} else \{      
    \$message = "You haven't got enough remaining of "+Describe(\$target[0], nil, \$actor)+" to make this.";      
  \}      
      
  \$message = replace_strings(\$message, "ORIGINAL_OBJECT", Describe(\$target[0], nil, \$actor));      
  EmitTo(\$actor, \$message);      
      
  return FALSE;      
\}      
      
/* -------------------------------------------------------------------------*/      
/* -------------------------------------------------------------------------*/      
/* -------------------------------------------------------------------------*/      
      
/* Check if this turns the object into a new object */      
if(((changemap2["newobject"]) \&\& (new_object = Spawn(changemap2["newobject"]))) \|\| ((changemap["newobject"]) \&\& (new_object = Spawn(changemap["newobject"]))))      
\{      
  new_object."base:environment" = Get(NRefOb(\$target[0]), "base:environment");      
/* If this is a new object, check what properties we should copy from the existing object */      
  if(changemap["newobject-properties"]) \{      
    /* loop through the properties, adding each one */      
    for(counter = 0; counter \< sizeof(changemap["newobject-properties"]); counter++) \{      
      Set(new_object, changemap["newobject-properties"][counter][1], Get(NRefOb(\$target[0]), changemap["newobject-properties"][counter][0]));      
    \}      
  \}      
  /* And again for changemap 2 */      
  if(changemap2["newobject-properties"]) \{      
    /* loop through the properties, adding each one */      
    for(counter = 0; counter \< sizeof(changemap2["newobject-properties"]); counter++) \{      
      Set(new_object, changemap2["newobject-properties"][counter][1], Get(NRefOb(\$target[0]), changemap2["newobject-properties"][counter][0]));      
    \}      
  \}      
\} else \{      
  new_object = NRefOb(\$target[0]);      
\}      
      
/* Check if we need to copy new properties to the object */      
if(changemap["properties"]) \{      
  /* loop through the properties, adding each one */      
  for(counter = 0; counter \< sizeof(changemap["properties"]); counter++) \{      
    /* Do we have a value specified? */      
    if(sizeof(changemap["properties"][counter]) \> 1)      
    \{      
      Set(new_object, changemap["properties"][counter][0], changemap["properties"][counter][1]);      
    \} else \{      
      /* Otherwise, use the modification description */      
      if(changemap2["value"]) \{      
        Set(new_object, changemap["properties"][counter][0], changemap2["value"]);      
      \} else if(changemap2["brief"]) \{      
        Set(new_object, changemap["properties"][counter][0], changemap2["brief"]);      
      \}      
    \}      
  \}      
\}      
/* And again for changemap 2 */      
if(changemap2["properties"]) \{      
  /* loop through the properties, adding each one */      
  for(counter = 0; counter \< sizeof(changemap2["properties"]); counter++) \{      
    /* Do we have a value specified? */      
    if(sizeof(changemap2["properties"][counter]) \> 1)      
    \{      
      Set(new_object, changemap2["properties"][counter][0], changemap2["properties"][counter][1]);      
    \} else \{      
      /* Otherwise, use the modification description */      
      if(changemap2["value"]) \{      
        Set(new_object, changemap2["properties"][counter][0], changemap2["value"]);      
      \} else if(changemap2["brief"]) \{      
        Set(new_object, changemap2["properties"][counter][0], changemap2["brief"]);      
      \}      
    \}      
  \}      
\}      
      
/* Check if we should make a skill roll, to see if the quality changes */      
if((tmp_string = changemap2["skill"]) \|\| (tmp_string = changemap["skill"]))      
\{      
  counter = Call(\$\{IronClaw:Lib:UrPeople:System\}, "roll", \$dicearray: (\{ \$actor."trait:mind", Get(\$actor, "skill:alteration:"+tmp_string), Get(\$actor, "career:alteration:"+tmp_string) \}) );      
  if(!new_object."trait:quality") new_object."trait:quality" = 4;      
  if(counter \> new_object."trait:quality") \{      
    new_object."trait:quality"++;      
  \} else if(counter \< new_object."trait:quality") \{      
    new_object."trait:quality"--;      
  \}      
\}      
      
/* Output an appropriate description of the action */      
      
/* Generate the descriptions */      
if((changemap["description"] \&\& sizeof(changemap["description"]) \> 1) \|\| (changemap2["description"] \&\& sizeof(changemap2["description"]) \> 1)) \{      
  /* properties for the 1st person and 3rd person description */      
  string description1;      
  string description3;      
      
  if(changemap2["description"] \&\& (sizeof(changemap2["description"]) \> 1)) \{      
    description1 = changemap2["description"][0];      
    description3 = Describe(\$actor) +" "+ changemap2["description"][1];      
  \} else \{      
    description1 = changemap["description"][0];      
    description3 = Describe(\$actor) +" "+ changemap["description"][1];      
  \}      
      
  /* replace keywords */      
  if(changemap2["brief"])      
  \{      
    description1 = replace_strings(description1, "BRIEF", changemap2["brief"]);      
    description3 = replace_strings(description3, "BRIEF", changemap2["brief"]);      
  \}      
  description1 = replace_strings(description1, "ORIGINAL_OBJECT", Describe(\$target, nil, \$actor));      
  description1 = replace_strings(description1, "NEW_OBJECT", Describe(new_object, nil, \$actor, STYLE_NONPOSS));      
  description1 = replace_strings(description1, "PRONOUN", \$actor."base:pronoun");      
  description1 = replace_strings(description1, "POSSESSIVE", \$actor."base:possessive");      
      
  description3 = replace_strings(description3, "ORIGINAL_OBJECT", Describe(\$target, \$actor));      
  description3 = replace_strings(description3, "NEW_OBJECT", Describe(new_object, \$actor, nil, STYLE_NONPOSS));      
  description3 = replace_strings(description3, "PRONOUN", \$actor."base:pronoun");      
  description3 = replace_strings(description3, "POSSESSIVE", \$actor."base:possessive");      
      
  /* Check what the modification is, for the description */      
  if(changemap2["modification"])      
  \{      
    description1 = replace_strings(description1, "MODIFICATION", changemap2["modification"]);      
    description3 = replace_strings(description3, "MODIFICATION", changemap2["modification"]);      
  \} else if(changemap["modification"]) \{      
    description1 = replace_strings(description1, "MODIFICATION", changemap["modification"]);      
    description3 = replace_strings(description3, "MODIFICATION", changemap["modification"]);      
  \}      
      
  /* Should add an evoke, if any, to the end of the description */      
  if(\$evoke) \{      
    description1 += ", " + \$evoke;      
    description3 += ", " + \$evoke;      
  \} else \{      
    description1 += ".";      
    description3 += ".";      
  \}      
      
  EmitTo(\$actor, description1);      
  EmitIn(\$actor."base:environment", description3, \$actor);      
      
  /* Slay the original object, if appropriate */      
  if((changemap["newobject"] \|\| changemap2["newobject"]) \&\& (!(changemap["noslay"]) \|\| (changemap["noslay"] == "false")) \&\& (!(changemap2["noslay"]) \|\| (changemap2["noslay"] == "false")))      
  \{      
    Slay(NRefOb(\$target[0]));      
  \}      
      
  return FALSE;      
\} else \{      
  /* Slay the original object, if appropriate */      
  if((changemap["newobject"] \|\| changemap2["newobject"]) \&\& (!(changemap["noslay"]) \|\| (changemap["noslay"] == "false")) \&\& (!(changemap2["noslay"]) \|\| (changemap2["noslay"] == "false")))      
  \{      
    Slay(NRefOb(\$target[0]));      
  \}      
      
  return TRUE;      
\}
      </Core:Property>
      <Core:Property property="merry:lib:replaceadj">
         X[M] string * words;      
int i;      
\$actor = nil /* defunct */;      
if(!\$object) return FALSE;      
if(!\$detail) \$detail = "default";      
      
/* remove plain as an adjective */      
\$object."details:default:adjective:plain" = nil;      
      
/* remove old adjective */      
if(\$(hook-oldvalue)) \{      
  words = explode(\$(hook-oldvalue), " ");      
  for(i = 0; i \< sizeof(words); i++)      
  \{      
    Set(\$object, "details:"+\$detail+":adjective:" + words[i], nil);      
  \}      
\}      
/* add new adjective */      
if(!Get(\$object, \$(hook-property))) return TRUE;      
words = explode(Get(\$object, \$(hook-property)), " ");      
for(i = 0; i \< sizeof(words); i++)      
\{      
  Set(\$object, "details:"+\$detail+":adjective:" + words[i], 1);      
\}      
return TRUE;
      </Core:Property>
      <Core:Property property="merry:lib:replacesname">
         X[M] string * words;      
int i;      
      
if(!\$object) return FALSE;      
      
/* remove old adjective */      
if(\$(hook-oldvalue)) \{      
  words = explode(\$(hook-oldvalue), " ");      
  for(i = 0; i \< sizeof(words); i++)      
  \{      
    Set(\$object, "details:default:sname:" + words[i], nil);      
  \}      
\}      
/* add new adjective */      
if(!\$(hook-property)) return TRUE;      
if(!Get(\$object, \$(hook-property))) return TRUE;      
words = explode(Get(\$object, \$(hook-property)), " ");      
for(i = 0; i \< sizeof(words); i++)      
\{      
  Set(\$object, "details:default:sname:" + words[i], 1);      
\}      
return TRUE;
      </Core:Property>
      <Core:Property property="merry:lib:valid-check">
         X[M] /*EmitTo(\$actor, "Args = " + dump_value(args));*/      
/* Check if we were given a direct object to add to the indirect object */      
/* Check if we were given a \$addition to add to the \$object */      
if(!\$addition) \{      
return TRUE;      
\}      
      
if(!\$object[0])      
\{      
  return FALSE;      
\}      
      
/* check we were only given one direct object */      
if(sizeof(\$addition) \> 1) \{      
  EmitTo(\$actor, "You can only add one object at a time");      
  return FALSE;      
\}      
      
/* this check should also be in the object being added */      
if(sizeof(\$object) \> 1) \{      
  EmitTo(\$actor, "You can only add to one object at a time");      
  return FALSE;      
\}      
      
/* Check if we are allowed to add the addition to the object */      
/*EmitTo(\$actor, "Adding " + Describe(\$addition) + " to " + Describe(\$object));*/      
if(!(Get(NRefOb(\$object[0]), "alteration:add:" + NRefDetail(\$object[0]) + ":" + Str(Get(NRefOb(\$addition[0]), "trait:objecttype")))))      
\{      
  EmitTo(\$actor, "You can't combine these objects");      
  return FALSE;      
\}     
 
\$detail = NRefDetail(\$object[0]); 
\$type = NRefOb(\$addition[0])."trait:objecttype"; 
if(\$detail == "wall-west" \|\| \$detail == "wall-east" \|\| \$detail == "wall-south" \|\| \$detail == "wall-north") \{ 
    /* If it has paneling or tile or wallpaper, they have to remove these elements before adding new */ 
    if(Get(\$this, "trait:" + \$detail + ":panel:type") == "paneled") \{ 
        EmitTo(\$actor, "You need to remove the existing paneling before modifying this wall."); 
        return FALSE; 
    \} else if((Get(\$this, "trait:" + \$detail + ":type") == "tiled" \|\| Get(\$this, "trait:" + \$detail + ":type") == "mosaic tiled") \&\& NRefOb(\$addition[0])."trait:type" != "wainscot") \{ 
        EmitTo(\$actor, "You need to remove the existing tile before modifying this wall."); 
        return FALSE; 
    \} else if(Get(\$this, "trait:" + \$detail + ":type") == "wallpapered" \&\& NRefOb(\$addition[0])."trait:type" != "wainscot") \{ 
        EmitTo(\$actor, "You need to remove the existing wallpaper before modifying this wall."); 
        return FALSE; 
    \} 
\} else if(\$detail == "ceiling") \{ 
    /* If it has paneling or boards, they have to remove them before adding new */ 
    if(Get(\$this, "trait:" + \$detail + ":panel:type")) \{ 
        EmitTo(\$actor, "You need to remove the existing paneling before modifying the ceiling."); 
        return FALSE; 
    \} 
\} else if(\$detail == "floor") \{ 
    /* If it has carpet or tiles, they have to remove them before adding new */ 
    if(Get(\$this, "trait:" + \$detail + ":carpet:type")) \{ 
        EmitTo(\$actor, "You need to remove the existing carpet before modifying the floor."); 
        return FALSE; 
    \} else if(Get(\$this, "trait:" + \$detail + ":type") == "tiled" \|\| Get(\$this, "details:" + \$detail + ":type") == "mosaic tiled") \{ 
        EmitTo(\$actor, "You need to remove the existing carpet before modifying the floor."); 
        return FALSE; 
    \} 
\} 
      
/* We can combine the objects */      
return TRUE;
      </Core:Property>
      <Core:Property property="merry:react-post:add-iob">
         X[M] if(!\$this.underconstruction) return TRUE; 
 
return Call(\$this, "add", \$addition: \$dob, \$target: \$iob);
      </Core:Property>
      <Core:Property property="merry:react-post:examine">
         X[M] \$help = "[OOC: This room is currently UNDER CONSTRUCTION. To add floor/wall/ceiling elements, use the ADD command (example: add wall panel to west wall). To remove floor/wall/ceiling elements, use the SMASH, PULL, OR TEAR commands (example: pull floor OR smash wall).]"; 
 
EmitTo(\$actor, TAG(\$help, "imp")); 
 
return TRUE;
      </Core:Property>
      <Core:Property property="merry:react-pre:add-iob">
         X[M] if(!\$this.underconstruction) return TRUE; 
 
if(!\$dob) return TRUE;      
     
return Call(\$this, "valid-check", \$addition: \$dob, \$object: \$iob);
      </Core:Property>
      <Core:Property property="merry:react-pre:smash-dob">
         X[M] if(!\$this.underconstruction) return TRUE; 
 
\$detail = NRefDetail(\$dob[0]);   
 
if(\$detail != "wall-west" \&\& \$detail != "wall-east" \&\& \$detail != "floor" \&\&  
   \$detail != "wall-south" \&\& \$detail != "wall-north" \&\& \$detail != "ceiling") \{ 
    return TRUE; 
\} 
 
if(Get(\$this, "trait:" + \$detail + ":panel:type")) \{ 
    EmitTo(\$actor, TAG("Fragments of wood fall at your feet as you smash " + Describe(\$dob[0]) + ".", "social:first")); 
    EmitIn(\$actor."base:environment", TAG("Fragments of paneling fall to the ground as " + Describe(\$actor) + " smashes " + Describe(\$dob[0]) + ".", "social:third"), \$actor); 
    Set(\$this, "trait:" + \$detail + ":panel:color", nil);   
    Set(\$this, "trait:" + \$detail + ":panel:material", nil);   
    Set(\$this, "trait:" + \$detail + ":panel:type", nil);   
    Set(\$this, "trait:" + \$detail + ":panel:brief", nil);   
    Set(\$this, "trait:" + \$detail + ":panel:examine", nil); 
    \$ob = Spawn(\$\{Ironclaw:Props:Crafting:Room:Debris\}); 
    \$ob."base:environment" = \$actor."base:environment"; 
    \$ob2 = Spawn(\$\{Ironclaw:Props:Crafting:Room:Debris\}); 
    \$ob2."base:environment" = \$actor; 
    Act(\$actor, "wear", \$articles: (\{ \$ob2 \}), \$silently: TRUE); 
    ::actionlog(\$actor: \$actor, \$action: "smash"); 
\} else if(Get(\$this, "trait:" + \$detail + ":type") == "tiled" \|\| Get(\$this, "trait:" + \$detail + ":type") == "mosaic tiled") \{ 
    EmitTo(\$actor, TAG("Fragments of tile fall at your feet as you smash " + Describe(\$dob[0]) + ".", "social:first")); 
    EmitIn(\$actor."base:environment", TAG("Fragments of tile fall to the ground as " + Describe(\$actor) + " smashes " + Describe(\$dob[0]) + ".", "social:third"), \$actor); 
    Set(\$this, "trait:" + \$detail + ":color", nil);   
    Set(\$this, "trait:" + \$detail + ":material", nil);   
    Set(\$this, "trait:" + \$detail + ":type", nil);   
    Set(\$this, "trait:" + \$detail + ":brief", nil);   
    Set(\$this, "trait:" + \$detail + ":examine", nil); 
    \$ob = Spawn(\$\{Ironclaw:Props:Crafting:Room:Debris\}); 
    \$ob."base:environment" = \$actor."base:environment"; 
    \$ob2 = Spawn(\$\{Ironclaw:Props:Crafting:Room:Debris\}); 
    \$ob2."base:environment" = \$actor; 
    Act(\$actor, "wear", \$articles: (\{ \$ob2 \}), \$silently: TRUE); 
    ::actionlog(\$actor: \$actor, \$action: "smash"); 
\} else if(Get(\$this, "trait:" + \$detail + ":type") == "parquet" \|\| Get(\$this, "trait:" + \$detail + ":type") == "covered") \{ 
    EmitTo(\$actor, TAG("Fragments of wood fall at your feet as you smash " + Describe(\$dob[0]) + ".", "social:first")); 
    EmitIn(\$actor."base:environment", TAG("Fragments of wood fall to the ground as " + Describe(\$actor) + " smashes " + Describe(\$dob[0]) + ".", "social:third"), \$actor); 
    Set(\$this, "trait:" + \$detail + ":color", nil);   
    Set(\$this, "trait:" + \$detail + ":material", nil);   
    Set(\$this, "trait:" + \$detail + ":type", nil);   
    Set(\$this, "trait:" + \$detail + ":brief", nil);   
    Set(\$this, "trait:" + \$detail + ":examine", nil); 
    \$ob = Spawn(\$\{Ironclaw:Props:Crafting:Room:Debris\}); 
    \$ob."base:environment" = \$actor."base:environment"; 
    \$ob2 = Spawn(\$\{Ironclaw:Props:Crafting:Room:Debris\}); 
    \$ob2."base:environment" = \$actor; 
    Act(\$actor, "wear", \$articles: (\{ \$ob2 \}), \$silently: TRUE); 
    ::actionlog(\$actor: \$actor, \$action: "smash"); 
\} 
   
return TRUE;
      </Core:Property>
      <Core:Property property="merry:react:close-what">
         X[M] if(NRefDetail(\$what[0]) != "window-south") return TRUE;

EmitTo(\$actor, " You close the broad latticework window. It protests with a faint squeak of wood against wood before closing with a click.");  
EmitIn(\$actor."base:environment", Describe(\$actor)+ " closes the broad latticework window. It protests with a faint squeak of wood against wood before closing with a click.", \$actor); 
return FALSE;
      </Core:Property>
      <Core:Property property="merry:react:open-what">
         X[M] if(NRefDetail(\$what[0]) != "window-south") return TRUE;

EmitTo(\$actor, " You open the broad latticework window. It swivels open on twin pin hinges, allowing a draft of clean sea breeze to wash through the room.");  

EmitIn(\$actor."base:environment", Describe(\$actor)+ " opens the broad latticework window,. It swivels open on twin pin hinges, allowing a draft of clean sea breeze to wash through the room.", \$actor); 
return FALSE;
      </Core:Property>
      <Core:Property property="merry:react:pull-dob">
         X[M] if(!\$this.underconstruction) return TRUE; 
 
\$detail = NRefDetail(\$dob[0]);   
 
if(\$detail != "floor") \{ 
    return TRUE; 
\} 
 
if(Get(\$this, "trait:carpet:type")) \{ 
    Set(\$this, "trait:carpet:color", nil);   
    Set(\$this, "trait:carpet:material", nil);   
    Set(\$this, "trait:carpet:type", nil);   
    Set(\$this, "trait:carpet:brief", nil);   
    Set(\$this, "trait:carpet:examine", nil); 
 
    EmitTo(\$actor, TAG("You pull the carpet from the floor, cutting and tearing it beyond further use.", "social:first")); 
    EmitIn(\$actor."base:environment", TAG(Describe(\$actor) + " pulls the carpet from the floor, cutting and tearing it beyond further use.", "social:third"), \$actor); 
 
    \$ob = Spawn(\$\{Ironclaw:Props:Crafting:Room:Debris\}); 
    \$ob."base:environment" = \$actor."base:environment"; 
    \$ob2 = Spawn(\$\{Ironclaw:Props:Crafting:Room:Debris\}); 
    \$ob2."base:environment" = \$actor; 
    Act(\$actor, "wear", \$articles: (\{ \$ob2 \}), \$silently: TRUE); 
 
    return FALSE; 
\} 
 
::actionlog(\$actor: \$actor, \$action: "pull"); 
   
return TRUE;
      </Core:Property>
      <Core:Property property="merry:react:tear-dob">
         X[M] if(!\$this.underconstruction) return TRUE; 
 
\$detail = NRefDetail(\$dob[0]);   
 
if(\$detail != "wall-west" \&\& \$detail != "wall-east" \&\& \$detail != "wall-south" \&\& \$detail != "wall-north") \{ 
    return TRUE; 
\} 
 
if(Get(\$this, "trait:" + \$detail + ":type") == "wallpapered") \{ 
    Set(\$this, "trait:" + \$detail + ":color", nil); 
    Set(\$this, "trait:" + \$detail + ":material", nil); 
    Set(\$this, "trait:" + \$detail + ":type", nil); 
    Set(\$this, "trait:" + \$detail + ":brief", nil); 
    Set(\$this, "trait:" + \$detail + ":examine", nil); 
    EmitTo(\$actor, TAG("The wallpaper falls at your feet as you tear it from the wall.", "social:first")); 
    EmitIn(\$actor."base:environment", TAG("The wallpaper falls to the ground as " + Describe(\$actor) + " tears it from the wall.", "social:third"), \$actor); 
    \$ob = Spawn(\$\{Ironclaw:Props:Crafting:Room:Debris\}); 
    \$ob."base:environment" = \$actor."base:environment"; 
    \$ob2 = Spawn(\$\{Ironclaw:Props:Crafting:Room:Debris\}); 
    \$ob2."base:environment" = \$actor; 
    Act(\$actor, "wear", \$articles: (\{ \$ob2 \}), \$silently: TRUE); 
\} 
 
::actionlog(\$actor: \$actor, \$action: "tear"); 
 
return FALSE;
      </Core:Property>
      <Core:Property property="revisions">
         (\{ 1511831467, "jominey", "E", 1511831490, "jominey", "E", 1511831676, "jominey", "E", 1520471978, "jominey", "X", 1520472134, "jominey", "E", 1520472554, "jominey", "K", 1520472635, "jominey", "E", 1520472649, "jominey", "E", 1520473014, "jominey", "E", 1520473074, "jominey", "E", 1520475057, "jominey", "E", 1520475477, "jominey", "K", 1520475616, "jominey", "K", 1520475795, "jominey", "K", 1520475808, "jominey", "E", 1520475823, "jominey", "E", 1520475852, "jominey", "K", 1520475934, "jominey", "K", 1520476304, "jominey", "K", 1520476577, "jominey", "K", 1520476650, "jominey", "K", 1520476687, "jominey", "K", 1520477365, "jominey", "E", 1520477369, "jominey", "E", 1520477385, "jominey", "E", 1520477387, "jominey", "E", 1520477405, "jominey", "E", 1520477407, "jominey", "E", 1520477691, "jominey", "K", 1520477990, "jominey", "K", 1520478103, "jominey", "E", 1520478267, "jominey", "K", 1520478295, "jominey", "K", 1521428277, "ezralee", "K", 1521429158, "jominey", "K", 1521429457, "jominey", "K", 1521429581, "jominey", "K", 1521513522, "jominey", "E", 1521687333, "jominey", "K", 1521769298, "lidiab", "E", 1521770464, "lidiab", "K", 1521770731, "lidiab", "K", 1521774877, "lidiab", "E", 1521784830, "lidiab", "E", 1521784910, "lidiab", "E", 1521784955, "lidiab", "E", 1521784988, "lidiab", "E", 1521785037, "lidiab", "E", 1521785116, "lidiab", "E", 1521785247, "lidiab", "E", 1521785260, "lidiab", "E", 1521785282, "lidiab", "E", 1521787481, "lidiab", "E", 1521787832, "lidiab", "E", 1521787891, "lidiab", "E", 1521787962, "lidiab", "E", 1521795563, "lidiab", "E", 1521795621, "lidiab", "E", 1521795682, "lidiab", "E", 1521838423, "jominey", "E", 1521838453, "jominey", "E", 1522204350, "jominey", "K", 1571523554, "sendnoodlez", "E", 1571531290, "jominey", "R" \})
      </Core:Property>
      <Core:Property property="skill:fatigue">1.0</Core:Property>
      <Core:Property property="sys:emit:population"/>
      <Core:Property property="volition">0</Core:Property>
    </Core:Properties>
    <Notes:Notes/>
  </Base:Thing>
</object>
